
### 暑假七月份九天训练计划PYTHON（修订版）

#### 概述
培训总时长：9天，每天学习4小时，共36小时(学习时间不包括当天的练习时间)  
培训对象：面向零基础的数建赛准备者  
培训方式: 每日学习(建议通过哔哩哔哩结合此处的介绍和教程建议学习)+每日练习(通过LeetCode刷题和此处也会给出一定的简单题型一起训练)  
备注: 建议使用 [PyCharm](https://www.jetbrains.com/zh-cn/pycharm/) 集成环境编辑器练习(可以申请14天免费试用专业版 后面可以用社区版)  

#### 分段计划
1. 掌握基本变量的使用，运算法则，逻辑语句（第1-3天）
2. 深层次的应用，包括算法（第4-6天）
3. 学习与数学建模大赛相关的库与应用（第7-9天）

---

### 第1段：掌握基本变量的使用，运算法则，逻辑语句（第1-3天）

**第一天：变量与基本数据类型**
- **第一小时**
  - 介绍培训内容和目标
  - 变量定义与命名规则
  - 数据类型（整数，浮点数，字符串，布尔值）
- **第二小时**
  - 基本运算符（加减乘除，取余，幂运算）
  - 类型转换
  - 简单练习题
- **第三小时**
  - 输入与输出
  - 格式化输出
  - 练习题与解答
- **第四小时**
  - 小项目：编写一个简单的计算器程序
  - 代码讲解与问题解答

**第二天：控制流与循环**
- **第一小时**
  - 条件语句（if, else, elif）
  - 逻辑运算符（and, or, not）
  - 练习题
- **第二小时**
  - 循环语句（for, while）
  - break与continue的使用
  - 练习题
- **第三小时**
  - 嵌套循环
  - 小项目：输出九九乘法表
  - 代码讲解与问题解答
- **第四小时**
  - 项目练习：猜数字游戏
  - 代码讲解与问题解答

**第三天：函数与模块**
- **第一小时**
  - 函数定义与调用
  - 参数与返回值
  - 练习题
- **第二小时**
  - 局部变量与全局变量
  - 模块与库的导入
  - 常用内置函数
  - 练习题
- **第三小时**
  - 小项目：制作一个简单的密码生成器
  - 代码讲解与问题解答
- **第四小时**
  - 复习与总结
  - 回顾本阶段重点内容
  - 练习与解答疑惑

---

### 第2段：深层次的应用，包括算法（第4-6天）

**第四天：基本算法**
- **第一小时**
  - 算法概念与重要性
  - 线性查找与二分查找
  - 练习题
- **第二小时**
  - 排序算法（冒泡排序，选择排序，插入排序）
  - 练习题
- **第三小时**
  - 递归概念与简单递归算法
  - 练习题
- **第四小时**
  - 项目练习：实现一个电话号码簿的查找与排序
  - 代码讲解与问题解答

**第五天：数据结构基础**
- **第一小时**
  - 列表与元组的使用
  - 基本操作（增删改查）
  - 练习题
- **第二小时**
  - 字典与集合的使用
  - 基本操作（增删改查）
  - 练习题
- **第三小时**
  - 队列与堆栈
  - 基本操作与应用
  - 练习题
- **第四小时**
  - 项目练习：实现一个简单的图书管理系统
  - 代码讲解与问题解答

**第六天：高级算法**
- **第一小时**
  - 动态规划概念与应用
  - 简单动态规划问题（斐波那契数列）
  - 练习题
- **第二小时**
  - 贪心算法概念与应用
  - 简单贪心算法问题（找零问题）
  - 练习题
- **第三小时**
  - 图算法基础（图的表示，深度优先搜索，广度优先搜索）
  - 练习题
- **第四小时**
  - 项目练习：最短路径问题
  - 代码讲解与问题解答

---

### 第3段：学习与数学建模大赛相关的库与应用（第7-9天）

**第七天：Numpy与Pandas**
- **第一小时**
  - Numpy基础
  - 数组创建与操作
  - 基本运算
- **第二小时**
  - Pandas基础
  - 数据结构（Series, DataFrame）
  - 数据导入与导出
- **第三小时**
  - 数据清洗与处理
  - 缺失值处理
  - 练习题
- **第四小时**
  - 项目练习：数据分析与处理
  - 代码讲解与问题解答

**第八天：Math与Random库**
- **第一小时**
  - Math库基础
  - 常用数学函数
  - 练习题
- **第二小时**
  - Random库基础
  - 随机数生成与应用
  - 练习题
- **第三小时**
  - 综合应用：模拟随机事件
  - 项目练习：随机数模拟与分析
- **第四小时**
  - 代码讲解与问题解答
  - 回顾与总结

**第九天：Matplotlib与综合应用**
- **第一小时**
  - Matplotlib基础
  - 基本图形绘制（折线图，柱状图，散点图）
  - 练习题
- **第二小时**
  - 高级图形绘制（热力图，箱线图，直方图）
  - 练习题
- **第三小时**
  - 项目练习：数据可视化项目
  - 代码讲解与问题解答
- **第四小时**
  - 综合项目：从数据处理到可视化
  - 代码讲解与问题解答
  - 培训总结与未来学习方向

---

### 结语

这九天的详细计划安排涵盖了基本编程技能的学习、算法和数据结构的应用，以及与数学建模大赛相关的库和实际应用的技能，为大学生数学建模大赛打下坚实的基础。

---

### 参考教程


# 编程入门第一天：第一小时

---

## 课程介绍

欢迎参加我们的编程入门课程！在接下来的几周里，我们将一起学习如何编写简单的程序，并逐步理解编程的基本概念。今天，我们将从最基础的内容开始，了解什么是变量，如何命名变量，以及Python中的几种基本数据类型。

---

## 培训内容和目标

### 培训内容：

1. 介绍培训内容和目标
2. 变量定义与命名规则
3. 数据类型（整数，浮点数，字符串，布尔值）

### 目标：

- 理解变量的概念及其在程序中的作用
- 学会如何正确命名变量
- 掌握Python中常见的数据类型

---

## 变量定义与命名规则

### 变量是什么？

变量是编程中的一个基本概念。可以把变量想象成一个容器，它可以存储数据。每个变量都有一个名字，我们可以通过这个名字来访问存储在变量中的数据。

#### 示例 1：变量的定义

假设我们有一个装满苹果的篮子，我们可以用一个变量来表示这个篮子中的苹果数量：

```python
apple_count = 5
```

在这个示例中，`apple_count` 就是变量名，而 `5` 是存储在 `apple_count` 变量中的值。

#### 示例 2：变量的重新赋值

如果我们后来又增加了3个苹果，我们可以更新 `apple_count` 变量的值：

```python
apple_count = 5
apple_count = apple_count + 3
```

此时，`apple_count` 的值变成了 `8`。

### 变量命名规则

1. **变量名必须以字母（a-z，A-Z）或下划线（_）开头**。
   - 正确：`name`，`_name`，`name1`
   - 错误：`1name`，`-name`

2. **变量名可以包含字母、数字和下划线，但不能包含空格或其他特殊字符**。
   - 正确：`user_name`，`user1`
   - 错误：`user-name`，`user name`

3. **变量名区分大小写**。
   - `name` 和 `Name` 是两个不同的变量。

4. **不要使用Python的保留字作为变量名**。例如：`if`，`else`，`for` 等。

#### 示例 3：变量命名的正确与错误示范

```python
# 正确的变量名
age = 25
user_name = "Alice"
height_in_cm = 170.5

# 错误的变量名
1st_user = "Bob"    # 不能以数字开头
user-name = "Eve"   # 不能包含特殊字符（如“-”）
```

### 变量使用示例

让我们看一个完整的示例，演示如何定义变量并使用它们：

```python
# 定义变量
name = "Alice"
age = 30
height = 165.5
is_student = True

# 打印变量的值
print("Name:", name)
print("Age:", age)
print("Height:", height)
print("Is Student:", is_student)

# 更新变量的值
age = age + 1
print("Updated Age:", age)
```

运行上述代码，将输出以下结果：

```
Name: Alice
Age: 30
Height: 165.5
Is Student: True
Updated Age: 31
```

---

## 数据类型

在Python中，数据类型决定了变量可以存储什么类型的值。常见的数据类型包括整数、浮点数、字符串和布尔值。

### 整数（int）

整数是没有小数部分的数字。例如：

```python
x = 10
y = -5
```

#### 示例 1：整数操作

```python
a = 10
b = 20
c = a + b
print("Sum:", c)  # 输出：Sum: 30
```

### 浮点数（float）

浮点数是有小数部分的数字。例如：

```python
pi = 3.14
temperature = -7.5
```

#### 示例 2：浮点数操作

```python
radius = 2.5
area = 3.14 * radius * radius
print("Area:", area)  # 输出：Area: 19.625
```

### 字符串（str）

字符串是由一系列字符组成的文本。在Python中，字符串可以用单引号或双引号括起来。例如：

```python
name = "Alice"
greeting = 'Hello, world!'
```

#### 示例 3：字符串操作

```python
first_name = "Alice"
last_name = "Smith"
full_name = first_name + " " + last_name
print("Full Name:", full_name)  # 输出：Full Name: Alice Smith
```

### 布尔值（bool）

布尔值只有两个可能的取值：`True`（真）和 `False`（假）。例如：

```python
is_student = True
is_sunny = False
```

#### 示例 4：布尔值操作

```python
is_raining = False
if is_raining:
    print("Take an umbrella!")
else:
    print("No need for an umbrella.")
```

### 数据类型综合示例

```python
# 定义各种数据类型的变量
age = 25
height = 175.5
name = "Alice"
is_student = True

# 打印变量的值和类型
print("Age:", age, "Type:", type(age))
print("Height:", height, "Type:", type(height))
print("Name:", name, "Type:", type(name))
print("Is Student:", is_student, "Type:", type(is_student))

# 更新变量的值
age = age + 1
height = height + 0.5
is_student = False

# 打印更新后的变量值
print("Updated Age:", age)
print("Updated Height:", height)
print("Updated Is Student:", is_student)
```

运行上面的代码，您将看到各个变量的值及其数据类型：

```
Age: 25 Type: <class 'int'>
Height: 175.5 Type: <class 'float'>
Name: Alice Type: <class 'str'>
Is Student: True Type: <class 'bool'>
Updated Age: 26
Updated Height: 176.0
Updated Is Student: False
```

---

## 小结

在今天的课程中，我们介绍了编程的基本概念，包括变量的定义与命名规则，以及Python中的几种基本数据类型。我们还通过多个详细的示例演示了这些概念的实际应用。理解这些概念是迈向编程世界的第一步。在接下来的课程中，我们将继续深入学习更多的编程知识，敬请期待！

---


# 编程入门第一天：第二小时

---

## 基本运算符

在编程中，我们经常需要对数据进行各种操作。Python提供了一些基本运算符来完成这些操作。常见的运算符包括加、减、乘、除、取余和幂运算。

### 加法运算（+）

加法运算用于将两个数字相加。

```python
a = 5
b = 3
result = a + b
print("5 + 3 =", result)  # 输出：5 + 3 = 8
```

### 减法运算（-）

减法运算用于将一个数字从另一个数字中减去。

```python
a = 5
b = 3
result = a - b
print("5 - 3 =", result)  # 输出：5 - 3 = 2
```

### 乘法运算（*）

乘法运算用于将两个数字相乘。

```python
a = 5
b = 3
result = a * b
print("5 * 3 =", result)  # 输出：5 * 3 = 15
```

### 除法运算（/）

除法运算用于将一个数字除以另一个数字。

```python
a = 5
b = 3
result = a / b
print("5 / 3 =", result)  # 输出：5 / 3 = 1.6666666666666667
```

### 取余运算（%）

取余运算用于返回两个数字相除的余数。

```python
a = 5
b = 3
result = a % b
print("5 % 3 =", result)  # 输出：5 % 3 = 2
```

### 幂运算（**）

幂运算用于将一个数字的幂次方。

```python
a = 5
b = 3
result = a ** b
print("5 ** 3 =", result)  # 输出：5 ** 3 = 125
```

---

## 类型转换

在编程中，有时需要将一种数据类型转换为另一种数据类型。Python提供了一些内置函数来进行类型转换。

### 转换为整数（int）

将其他数据类型转换为整数。

```python
a = "10"
b = int(a)
print("字符串 '10' 转换为整数 =", b)  # 输出：字符串 '10' 转换为整数 = 10
```

### 转换为浮点数（float）

将其他数据类型转换为浮点数。

```python
a = "10.5"
b = float(a)
print("字符串 '10.5' 转换为浮点数 =", b)  # 输出：字符串 '10.5' 转换为浮点数 = 10.5
```

### 转换为字符串（str）

将其他数据类型转换为字符串。

```python
a = 10
b = str(a)
print("整数 10 转换为字符串 =", b)  # 输出：整数 10 转换为字符串 = '10'
```

### 转换为布尔值（bool）

将其他数据类型转换为布尔值。

```python
a = 0
b = bool(a)
print("整数 0 转换为布尔值 =", b)  # 输出：整数 0 转换为布尔值 = False

a = 1
b = bool(a)
print("整数 1 转换为布尔值 =", b)  # 输出：整数 1 转换为布尔值 = True
```

---

## 简单练习题

通过以下练习题来巩固我们学到的内容。

### 练习题 1

定义两个变量 `a` 和 `b`，并计算它们的和、差、积、商、余数和幂次。此外，将计算结果转换为字符串，并打印它们的类型。

```python
a = 7
b = 2

sum_result = a + b
difference_result = a - b
product_result = a * b
quotient_result = a / b
remainder_result = a % b
power_result = a ** b

# 转换为字符串
sum_str = str(sum_result)
difference_str = str(difference_result)
product_str = str(product_result)
quotient_str = str(quotient_result)
remainder_str = str(remainder_result)
power_str = str(power_result)

print("和 =", sum_str, "类型 =", type(sum_str))
print("差 =", difference_str, "类型 =", type(difference_str))
print("积 =", product_str, "类型 =", type(product_str))
print("商 =", quotient_str, "类型 =", type(quotient_str))
print("余数 =", remainder_str, "类型 =", type(remainder_str))
print("幂次 =", power_str, "类型 =", type(power_str))
```

### 练习题 2

将一个浮点数转换为整数，并将一个整数转换为浮点数。计算这两个数的和、差、积、商、余数和幂次，并打印结果及其数据类型。

```python
float_number = 10.75
int_number = int(float_number)
print("浮点数 10.75 转换为整数 =", int_number)

int_number = 10
float_number = float(int_number)
print("整数 10 转换为浮点数 =", float_number)

# 计算运算结果
sum_result = int_number + float_number
difference_result = int_number - float_number
product_result = int_number * float_number
quotient_result = int_number / float_number
remainder_result = int_number % int(float_number)  # 注意这里的类型转换
power_result = int_number ** int(float_number)

print("和 =", sum_result, "类型 =", type(sum_result))
print("差 =", difference_result, "类型 =", type(difference_result))
print("积 =", product_result, "类型 =", type(product_result))
print("商 =", quotient_result, "类型 =", type(quotient_result))
print("余数 =", remainder_result, "类型 =", type(remainder_result))
print("幂次 =", power_result, "类型 =", type(power_result))
```

### 练习题 3

编写一个程序，要求用户输入两个整数，然后计算它们的和、差、积、商、余数和幂次。将所有结果转换为字符串，并打印它们的类型。

```python
# 获取用户输入
a = int(input("请输入第一个整数："))
b = int(input("请输入第二个整数："))

# 计算结果
sum_result = a + b
difference_result = a - b
product_result = a * b
quotient_result = a / b
remainder_result = a % b
power_result = a ** b

# 转换为字符串
sum_str = str(sum_result)
difference_str = str(difference_result)
product_str = str(product_result)
quotient_str = str(quotient_result)
remainder_str = str(remainder_result)
power_str = str(power_result)

print("和 =", sum_str, "类型 =", type(sum_str))
print("差 =", difference_str, "类型 =", type(difference_str))
print("积 =", product_str, "类型 =", type(product_str))
print("商 =", quotient_str, "类型 =", type(quotient_str))
print("余数 =", remainder_str, "类型 =", type(remainder_str))
print("幂次 =", power_str, "类型 =", type(power_str))
```

### 练习题 4

编写一个程序，要求用户输入一个浮点数和一个整数，然后进行加、减、乘、除、取余和幂运算，并将结果转换为布尔值。如果结果为0，则布尔值为False，否则为True。

```python
# 获取用户输入
float_number = float(input("请输入一个浮点数："))
int_number = int(input("请输入一个整数："))

# 计算结果
sum_result = float_number + int_number
difference_result = float_number - int_number
product_result = float_number * int_number
quotient_result = float_number / int_number
remainder_result = float_number % int_number
power_result = float_number ** int_number

# 转换为布尔值
sum_bool = bool(sum_result)
difference_bool = bool(difference_result)
product_bool = bool(product_result)
quotient_bool = bool(quotient_result)
remainder_bool = bool(remainder_result)
power_bool = bool(power_result)

print("和 =", sum_bool)
print("差 =", difference_bool)
print("积 =", product_bool)
print("商 =", quotient_bool)
print("余数 =", remainder_bool)
print("幂次 =", power_bool)
```

---

## 小结

在今天的课程中，我们学习了Python中的基本运算符，包括加减乘除、取余和幂运算。我们还学习了如何进行类型转换，并通过难度稍高的练习题来巩固所学内容。在接下来的课程中，我们将继续深入学习更多的编程知识，敬请期待！

---


# 编程入门第一天：第三小时

---

## 输入与输出

在编程中，输入和输出是非常重要的概念。输入是指从用户或其他源获取数据，而输出是指将数据展示给用户或发送到其他地方。在Python中，我们使用`input()`函数获取输入，使用`print()`函数输出数据。

### 获取用户输入

我们可以使用`input()`函数从用户那里获取输入。获取到的输入默认是字符串类型。

```python
name = input("请输入你的名字：")
print("你好，", name)
```

### 输出数据

我们可以使用`print()`函数将数据输出到控制台。

```python
age = 25
print("你的年龄是：", age)
```

---

## 格式化输出

有时候，我们需要以特定的格式输出数据。在Python中，可以使用`format()`方法或者f字符串（格式化字符串）来格式化输出。

### 使用`format()`方法

`format()`方法可以将多个值插入到字符串中的指定位置。

```python
name = "Alice"
age = 30
print("名字：{}，年龄：{}".format(name, age))
```

### 使用f字符串

f字符串是一种更简洁的格式化方式。可以直接在字符串中插入变量。

```python
name = "Alice"
age = 30
print(f"名字：{name}，年龄：{age}")
```

### 格式化数字

我们可以使用格式化字符串来控制数字的显示方式。

```python
pi = 3.141592653589793
print("Pi的值为：{:.2f}".format(pi))  # 保留两位小数
print(f"Pi的值为：{pi:.2f}")  # 使用f字符串保留两位小数
```

---

## 练习题与解答

通过以下练习题来巩固我们学到的内容。

### 练习题 1

编写一个程序，要求用户输入姓名和年龄，然后格式化输出一条消息，显示“你好，{姓名}，你的年龄是{年龄}岁”。

```python
# 获取用户输入
name = input("请输入你的名字：")
age = input("请输入你的年龄：")

# 输出格式化消息
print(f"你好，{name}，你的年龄是{age}岁")
```

### 练习题 2

编写一个程序，要求用户输入一个浮点数，格式化输出该浮点数的值，保留两位小数。

```python
# 获取用户输入
number = float(input("请输入一个浮点数："))

# 格式化输出
print(f"输入的浮点数保留两位小数后的值为：{number:.2f}")
```

### 练习题 3

编写一个程序，要求用户输入三个整数，计算它们的和、平均值，并格式化输出结果。

```python
# 获取用户输入
num1 = int(input("请输入第一个整数："))
num2 = int(input("请输入第二个整数："))
num3 = int(input("请输入第三个整数："))

# 计算和与平均值
sum_result = num1 + num2 + num3
average_result = sum_result / 3

# 格式化输出结果
print(f"三个整数的和为：{sum_result}，平均值为：{average_result:.2f}")
```

### 练习题 4

编写一个程序，要求用户输入一个半径值，计算圆的面积并格式化输出，保留两位小数。提示：圆的面积公式为`π * r ** 2`，其中`π`取3.14159。

```python
# 获取用户输入
radius = float(input("请输入圆的半径："))

# 计算圆的面积
pi = 3.14159
area = pi * radius ** 2

# 格式化输出结果
print(f"半径为{radius}的圆的面积为：{area:.2f}")
```

### 练习题 5

编写一个程序，要求用户输入两个数，计算它们的商，并格式化输出，保留三位小数。

```python
# 获取用户输入
num1 = float(input("请输入第一个数："))
num2 = float(input("请输入第二个数："))

# 计算商
quotient = num1 / num2

# 格式化输出结果
print(f"{num1} 除以 {num2} 的结果是：{quotient:.3f}")
```

---

## 小结

在今天的课程中，我们学习了Python中的输入与输出，了解了如何使用`input()`函数获取用户输入，使用`print()`函数输出数据。我们还学习了格式化输出的方法，包括使用`format()`和f字符串。最后，通过练习题巩固了所学内容。在接下来的课程中，我们将继续深入学习更多的编程知识，敬请期待！

---


# 编程入门第一天：第四小时

---

## 对基本数据类型的一些常用函数介绍

在编程中，Python提供了许多常用函数来操作基本数据类型。这些函数可以帮助我们处理字符串、数字等常见任务。

### 字符串操作函数

#### 字符串拼接

我们可以使用`+`运算符来拼接两个或多个字符串。

```python
str1 = "Hello"
str2 = "World"
result = str1 + " " + str2
print(result)  # 输出：Hello World
```

#### 字符串长度

使用`len()`函数可以获取字符串的长度。

```python
str1 = "Hello"
length = len(str1)
print(length)  # 输出：5
```

#### 字符串大小写转换

使用`upper()`和`lower()`函数可以将字符串转换为大写或小写。

```python
str1 = "Hello World"
print(str1.upper())  # 输出：HELLO WORLD
print(str1.lower())  # 输出：hello world
```

#### 去除字符串两端的空格

使用`strip()`函数可以去除字符串两端的空格。

```python
str1 = "   Hello World   "
print(str1.strip())  # 输出：Hello World
```

### 数字操作函数

#### 求绝对值

使用`abs()`函数可以获取数字的绝对值。

```python
num = -5
print(abs(num))  # 输出：5
```

#### 四舍五入

使用`round()`函数可以对数字进行四舍五入。

```python
num = 3.14159
print(round(num, 2))  # 输出：3.14
```

#### 求最大值和最小值

使用`max()`和`min()`函数可以求一组数中的最大值和最小值。

```python
print(max(1, 2, 3, 4, 5))  # 输出：5
print(min(1, 2, 3, 4, 5))  # 输出：1
```

---

## 小项目：编写一个简单的计算器程序

现在，我们将使用所学的知识编写一个简单的计算器程序。这个程序可以进行加、减、乘、除运算，并且支持连续计算。

### 代码示例

```python
def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    if y == 0:
        return "除数不能为零"
    return x / y

print("欢迎使用简单计算器")
print("选择操作：")
print("1. 加法")
print("2. 减法")
print("3. 乘法")
print("4. 除法")

while True:
    choice = input("输入你的选择(1/2/3/4): ")

    if choice in ('1', '2', '3', '4'):
        num1 = float(input("输入第一个数字: "))
        num2 = float(input("输入第二个数字: "))

        if choice == '1':
            print(f"{num1} + {num2} = {add(num1, num2)}")

        elif choice == '2':
            print(f"{num1} - {num2} = {subtract(num1, num2)}")

        elif choice == '3':
            print(f"{num1} * {num2} = {multiply(num1, num2)}")

        elif choice == '4':
            print(f"{num1} / {num2} = {divide(num1, num2)}")
        
        # 检查是否继续计算
        next_calculation = input("是否继续计算? (yes/no): ")
        if next_calculation.lower() != 'yes':
            break
    else:
        print("无效输入，请重新输入")
```

### 代码讲解

1. **定义函数**：我们定义了四个函数`add()`、`subtract()`、`multiply()`和`divide()`，分别用于执行加法、减法、乘法和除法操作。

2. **用户界面**：我们打印操作选项，提示用户选择一种操作。

3. **获取用户输入**：我们使用`input()`函数获取用户选择的操作和输入的数字。

4. **执行计算并输出结果**：根据用户选择的操作，调用相应的函数执行计算，并将结果打印出来。

5. **循环计算**：程序使用`while True`循环，使用户可以连续进行计算，直到用户选择退出。

---

## 练习题与解答

通过以下练习题来巩固我们学到的内容。

### 练习题

改进计算器程序，增加错误处理，当用户输入的不是数字时，提示用户重新输入。

#### 代码示例

```python
def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    if y == 0:
        return "除数不能为零"
    return x / y

def modulus(x, y):
    return x % y

def power(x, y):
    return x ** y

print("欢迎使用简单计算器")
print("选择操作：")
print("1. 加法")
print("2. 减法")
print("3. 乘法")
print("4. 除法")
print("5. 取余")
print("6. 幂运算")

while True:
    choice = input("输入你的选择(1/2/3/4/5/6): ")

    if choice in ('1', '2', '3', '4', '5', '6'):
        try:
            num1 = float(input("输入第一个数字: "))
            num2 = float(input("输入第二个数字: "))
        except ValueError:
            print("无效输入，请输入数字")
            continue

        if choice == '1':
            print(f"{num1} + {num2} = {add(num1, num2)}")

        elif choice == '2':
            print(f"{num1} - {num2} = {subtract(num1, num2)}")

        elif choice == '3':
            print(f"{num1} * {num2} = {multiply(num1, num2)}")

        elif choice == '4':
            print(f"{num1} / {num2} = {divide(num1, num2)}")

        elif choice == '5':
            print(f"{num1} % {num2} = {modulus(num1, num2)}")

        elif choice == '6':
            print(f"{num1} ** {num2} = {power(num1, num2)}")
        
        # 检查是否继续计算
        next_calculation = input("是否继续计算? (yes/no): ")
        if next_calculation.lower() != 'yes':
            break
    else:
        print("无效输入，请重新输入")
```

---

## 小结

在今天的课程中，我们学习了Python中与基本类型有关的常用函数，包括字符串操作和数字操作。我们还编写了一个简单的计算器程序，通过这个小项目，我们巩固了所学知识，并练习了编写函数和处理用户输入的技巧。最后，我们通过练习题来进一步提升编程能力。在接下来的课程中，我们将继续深入学习更多的编程知识，敬请期待！

---


# 编程入门第二天：第一小时

---

## 条件语句（if, else, elif）

条件语句用于根据条件的真假来执行不同的代码块。

### if 语句

```python
x = 10
if x > 5:
    print("x 大于 5")
```

### if-else 语句

```python
x = 10
if x > 15:
    print("x 大于 15")
else:
    print("x 不大于 15")
```

### if-elif-else 语句

```python
x = 10
if x > 15:
    print("x 大于 15")
elif x > 5:
    print("x 大于 5 小于等于 15")
else:
    print("x 小于等于 5")
```

---

## 逻辑运算符（and, or, not）

逻辑运算符用于组合条件。

### and 运算符

```python
x = 10
y = 20
if x > 5 and y > 15:
    print("x 大于 5 且 y 大于 15")
```

### or 运算符

```python
x = 10
y = 20
if x > 15 or y > 15:
    print("x 大于 15 或 y 大于 15")
```

### not 运算符

```python
x = 10
if not x > 15:
    print("x 不大于 15")
```

---

## 循环语句（for, while）

循环语句用于重复执行某段代码。

### for 循环

```python
for i in range(5):
    print(i)
```

### while 循环

```python
x = 0
while x < 5:
    print(x)
    x += 1
```

---

## break 与 continue 的使用

### break 语句

用于提前退出循环。

```python
for i in range(10):
    if i == 5:
        break
    print(i)
```

### continue 语句

用于跳过当前迭代，继续下一次循环。

```python
for i in range(10):
    if i == 5:
        continue
    print(i)
```

---

## 嵌套循环

循环中嵌套循环。

```python
for i in range(3):
    for j in range(3):
        print(f"i={i}, j={j}")
```

---

## 练习题

### 练习题 1

编写一个程序，要求用户输入一个整数，然后打印从1到该整数的所有奇数。

### 练习题 2

编写一个程序，要求用户输入一个整数，然后计算从1到该整数的所有整数的和。

### 练习题 3

编写一个程序，打印一个5x5的乘法表。

#### 代码示例

```python
for i in range(1, 6):
    for j in range(1, 6):
        print(i * j, end="\t")
    print()
```

---

## 小结

在这一小时的课程中，我们学习了条件语句、逻辑运算符、循环语句以及break和continue的使用，并了解了嵌套循环。通过练习题，我们巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第二天：第二小时

---

## 小项目：输出九九乘法表

九九乘法表是一个经典的编程练习，通过这个项目我们可以熟悉嵌套循环的使用。

### 代码示例

```python
# 输出九九乘法表
for i in range(1, 10):
    for j in range(1, 10):
        print(f"{i} * {j} = {i * j}", end="\t")
    print()
```

### 代码讲解

1. **外层循环**：外层循环控制乘数的第一个数，从1循环到9。
   
   ```python
   for i in range(1, 10):
   ```

2. **内层循环**：内层循环控制乘数的第二个数，从1循环到9。
   
   ```python
   for j in range(1, 10):
   ```

3. **打印结果**：在内层循环中，我们使用`print`函数输出乘法结果，使用`end="\t"`表示输出后不换行，而是用制表符分隔每个结果。
   
   ```python
   print(f"{i} * {j} = {i * j}", end="\t")
   ```

4. **换行**：每一行结束后，使用`print()`输出一个空行，以便开始新的乘法表行。
   
   ```python
   print()
   ```

---

## 练习题与解答

### 问题

扩展九九乘法表程序，使其输出形式更加美观，每个结果对齐。

#### 代码示例

```python
# 输出美观的九九乘法表
for i in range(1, 10):
    for j in range(1, 10):
        print(f"{i} * {j} = {i * j:2d}", end="  ")
    print()
```

### 代码讲解

1. **格式化字符串**：我们使用`{i * j:2d}`进行格式化输出，其中`2d`表示两位整数，保证每个结果占据两位空间，这样可以使表格对齐。
   
   ```python
   print(f"{i} * {j} = {i * j:2d}", end="  ")
   ```

2. **调整间距**：为了使输出结果更加美观，我们使用`end="  "`来增加每个结果之间的间距。

---

## 小结

在这一小时的课程中，我们通过输出九九乘法表的项目，熟悉了嵌套循环的使用，并学习了如何美化输出结果。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第二天：第三小时

---

## 小项目：猜数字游戏

猜数字游戏是一个经典的编程练习，通过这个项目我们可以熟悉随机数生成、用户输入和条件判断的使用。

### 代码示例

```python
import random

def guess_number():
    number = random.randint(1, 100)
    attempts = 0
    while True:
        guess = input("猜一个 1 到 100 之间的数字: ")
        try:
            guess = int(guess)
            attempts += 1
            if guess < number:
                print("太小了！")
            elif guess > number:
                print("太大了！")
            else:
                print(f"恭喜你，猜对了！你一共猜了 {attempts} 次。")
                break
        except ValueError:
            print("请输入一个有效的数字。")

guess_number()
```

### 代码讲解

1. **导入模块**：我们使用`random`模块生成随机数。

   ```python
   import random
   ```

2. **定义函数**：定义一个名为`guess_number`的函数，用于实现猜数字游戏的逻辑。

   ```python
   def guess_number():
   ```

3. **生成随机数**：使用`random.randint(1, 100)`生成一个1到100之间的随机整数。

   ```python
   number = random.randint(1, 100)
   ```

4. **初始化尝试次数**：设置一个变量`attempts`用于记录猜测的次数。

   ```python
   attempts = 0
   ```

5. **循环**：使用`while True`循环来不断提示用户输入猜测的数字。

   ```python
   while True:
   ```

6. **获取用户输入**：使用`input()`函数获取用户输入，并尝试将其转换为整数。

   ```python
   guess = input("猜一个 1 到 100 之间的数字: ")
   ```

7. **异常处理**：如果用户输入的不是有效的数字，捕获`ValueError`并提示用户重新输入。

   ```python
   try:
       guess = int(guess)
   except ValueError:
       print("请输入一个有效的数字。")
       continue
   ```

8. **增加尝试次数**：每次用户输入一个有效的猜测，尝试次数加1。

   ```python
   attempts += 1
   ```

9. **条件判断**：根据用户输入的数字与生成的随机数进行比较，并输出相应的提示。

   ```python
   if guess < number:
       print("太小了！")
   elif guess > number:
       print("太大了！")
   else:
       print(f"恭喜你，猜对了！你一共猜了 {attempts} 次。")
       break
   ```

10. **调用函数**：调用`guess_number`函数开始游戏。

    ```python
    guess_number()
    ```

---

## 练习题与解答

### 问题

扩展猜数字游戏，增加一个提示功能，当用户猜错时，提示猜错的次数和正确答案与猜测数字的差距。

#### 代码示例

```python
import random

def guess_number():
    number = random.randint(1, 100)
    attempts = 0
    while True:
        guess = input("猜一个 1 到 100 之间的数字: ")
        try:
            guess = int(guess)
            attempts += 1
            if guess < number:
                print(f"太小了！你已经猜了 {attempts} 次。差距是 {number - guess}")
            elif guess > number:
                print(f"太大了！你已经猜了 {attempts} 次。差距是 {guess - number}")
            else:
                print(f"恭喜你，猜对了！你一共猜了 {attempts} 次。")
                break
        except ValueError:
            print("请输入一个有效的数字。")

guess_number()
```

### 代码讲解

1. **增加差距提示**：在用户猜测错误时，增加差距提示，告诉用户猜测数字与正确答案的差距。

   ```python
   if guess < number:
       print(f"太小了！你已经猜了 {attempts} 次。差距是 {number - guess}")
   elif guess > number:
       print(f"太大了！你已经猜了 {attempts} 次。差距是 {guess - number}")
   ```

---

## 小结

在这一小时的课程中，我们通过猜数字游戏的项目，熟悉了随机数生成、用户输入和条件判断的使用。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第二天：第四小时

---

## 函数定义与调用

函数是组织好的、可重复使用的、用于实现单一或相关联功能的代码段。函数能提高应用的模块性和代码的重复利用率。

### 定义函数

使用`def`关键字定义函数。

```python
def greet():
    print("Hello, World!")
```

### 调用函数

直接调用函数名即可。

```python
greet()  # 输出：Hello, World!
```

---

## 参数与返回值

函数可以接受参数并返回值。

### 带参数的函数

```python
def greet(name):
    print(f"Hello, {name}!")
```

调用时传入参数。

```python
greet("Alice")  # 输出：Hello, Alice!
```

### 带返回值的函数

使用`return`语句返回值。

```python
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 输出：8
```

---

## 局部变量与全局变量

### 局部变量

在函数内部定义的变量，作用域仅限于函数内部。

```python
def func():
    x = 10  # 局部变量
    print(x)

func()  # 输出：10
print(x)  # 错误：x未定义
```

### 全局变量

在函数外部定义的变量，可以在整个程序中访问。

```python
x = 10  # 全局变量

def func():
    print(x)

func()  # 输出：10
print(x)  # 输出：10
```

### global 关键字

在函数内部修改全局变量时，需要使用`global`关键字。

```python
x = 10  # 全局变量

def func():
    global x
    x = 20

func()
print(x)  # 输出：20
```

---

## 模块与库的导入

### 导入模块

使用`import`关键字导入模块。

```python
import math

print(math.sqrt(16))  # 输出：4.0
```

### 导入特定函数

使用`from ... import ...`语句导入特定函数。

```python
from math import sqrt

print(sqrt(16))  # 输出：4.0
```

### 导入并重命名

使用`as`关键字重命名模块或函数。

```python
import math as m

print(m.sqrt(16))  # 输出：4.0
```

---

## 常用内置函数

Python提供了许多常用的内置函数，这里列出一些常见的。

### print()

用于输出信息到控制台。

```python
print("Hello, World!")  # 输出：Hello, World!
```

### len()

用于获取序列（如字符串、列表等）的长度。

```python
print(len("Hello"))  # 输出：5
```

### range()

用于生成一个整数序列，常用于循环中。

```python
for i in range(5):
    print(i)
```

### type()

用于获取变量的类型。

```python
print(type(123))  # 输出：<class 'int'>
print(type("Hello"))  # 输出：<class 'str'>
```

### input()

用于获取用户输入。

```python
name = input("Enter your name: ")
print(f"Hello, {name}!")
```

---

## 练习题

### 练习题 1

编写一个函数，接受两个参数并返回它们的乘积。

#### 示例

```python
def multiply(a, b):
    return a * b

result = multiply(3, 4)
print(result)  # 输出：12
```

### 练习题 2

编写一个程序，要求用户输入一个字符串，然后使用函数判断该字符串是否是回文（正读和反读都一样的字符串）。

#### 示例

```python
def is_palindrome(s):
    return s == s[::-1]

word = input("Enter a word: ")
if is_palindrome(word):
    print(f"{word} 是回文")
else:
    print(f"{word} 不是回文")
```

---

## 小结

在这一小时的课程中，我们学习了函数的定义与调用、参数与返回值、局部变量与全局变量、模块与库的导入以及常用内置函数。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第三天：第一小时

---

## 小项目：BMI计算器

创建一个BMI计算器，用户输入身高和体重，程序计算并输出BMI值以及相应的健康状态。

### 代码示例

```python
def calculate_bmi(weight, height):
    bmi = weight / (height ** 2)
    return bmi

def bmi_status(bmi):
    if bmi < 18.5:
        return "体重过轻"
    elif 18.5 <= bmi < 24.9:
        return "体重正常"
    elif 25 <= bmi < 29.9:
        return "超重"
    else:
        return "肥胖"

def bmi_calculator():
    try:
        weight = float(input("请输入体重(kg): "))
        height = float(input("请输入身高(m): "))
    except ValueError:
        print("输入无效，请输入数字。")
        return
    
    bmi = calculate_bmi(weight, height)
    status = bmi_status(bmi)
    
    print(f"你的BMI是: {bmi:.2f}")
    print(f"健康状态: {status}")

bmi_calculator()
```

### 代码讲解

1. **函数定义**：
   - `calculate_bmi`函数计算BMI值。
   - `bmi_status`函数根据BMI值返回相应的健康状态。
2. **用户输入**：使用`input()`函数获取用户输入的体重和身高，并转换为浮点数。
3. **异常处理**：使用`try-except`块捕获并处理输入的无效值。
4. **计算与输出**：计算BMI值并输出BMI值及相应的健康状态。

---


# 编程入门第三天：第二小时

---

## 小项目：天气信息查询（模拟）

创建一个模拟的天气信息查询系统，用户输入城市名称，程序返回该城市的天气信息。

### 代码示例

```python
def get_weather(city):
    weather_data = {
        "北京": "晴，气温 25°C",
        "上海": "阴，气温 22°C",
        "广州": "多云，气温 30°C",
        "深圳": "雷阵雨，气温 28°C"
    }
    return weather_data.get(city, "未找到该城市的天气信息")

def weather_query():
    city = input("请输入城市名称: ")
    weather = get_weather(city)
    print(f"{city}的天气信息: {weather}")

weather_query()
```

### 代码讲解

1. **数据存储**：使用字典`weather_data`存储城市名称和对应的天气信息。
2. **查询功能**：`get_weather`函数根据城市名称查询天气信息。
3. **用户输入**：使用`input()`函数获取用户输入的城市名称。
4. **输出结果**：输出查询到的天气信息。

---


# 编程入门第三天：第三小时

---

## 小项目：简易记事本

创建一个简易记事本，用户可以添加、查看和删除笔记。

### 代码示例

```python
notes = []

def add_note():
    note = input("请输入笔记内容: ")
    notes.append(note)
    print("笔记已添加")

def view_notes():
    if not notes:
        print("没有笔记")
    else:
        for index, note in enumerate(notes, start=1):
            print(f"{index}. {note}")

def delete_note():
    try:
        index = int(input("请输入要删除的笔记编号: ")) - 1
        if 0 <= index < len(notes):
            deleted_note = notes.pop(index)
            print(f"已删除笔记: {deleted_note}")
        else:
            print("无效的编号")
    except ValueError:
        print("输入无效，请输入数字")

def notebook():
    while True:
        print("\n选择操作：")
        print("1. 添加笔记")
        print("2. 查看笔记")
        print("3. 删除笔记")
        print("4. 退出")
        
        choice = input("输入你的选择(1/2/3/4): ")
        
        if choice == '4':
            print("退出程序")
            break
        elif choice == '1':
            add_note()
        elif choice == '2':
            view_notes()
        elif choice == '3':
            delete_note()
        else:
            print("无效输入，请重新输入")

notebook()
```

### 代码讲解

1. **数据存储**：使用列表`notes`存储笔记。
2. **添加笔记**：`add_note`函数用于添加新笔记。
3. **查看笔记**：`view_notes`函数用于查看所有笔记。
4. **删除笔记**：`delete_note`函数根据编号删除笔记。
5. **菜单选择**：提供菜单让用户选择添加、查看或删除笔记。

---


# 编程入门第三天：第四小时

---

## 小项目：简单图书管理系统

创建一个简单的图书管理系统，支持添加图书、显示所有图书、查找图书和删除图书。

### 代码示例

```python
books = []

def add_book():
    title = input("请输入书名: ")
    author = input("请输入作者: ")
    books.append({"title": title, "author": author})
    print("图书添加成功")

def display_books():
    if not books:
        print("没有图书记录")
        return
    for book in books:
        print(f"书名: {book['title']}, 作者: {book['author']}")

def find_book():
    title = input("请输入要查找的书名: ")
    for book in books:
        if book['title'] == title:
            print(f"找到图书: 书名: {book['title']}, 作者: {book['author']}")
            return
    print("未找到图书")

def delete_book():
    title = input("请输入要删除的书名: ")
    for book in books:
        if book['title'] == title:
            books.remove(book)
            print("图书删除成功")
            return
    print("未找到图书")

def book_system():
    while True:
        print("选择操作：")
        print("1. 添加图书")
        print("2. 显示所有图书")
        print("3. 查找图书")
        print("4. 删除图书")
        print("5. 退出")
        
        choice = input("输入你的选择(1/2/3/4/5): ")
        
        if choice == '5':
            print("退出程序")
            break
        elif choice == '1':
            add_book()
        elif choice == '2':
            display_books()
        elif choice == '3':
            find_book()
        elif choice == '4':
            delete_book()
        else:
            print("无效输入，请重新输入")

book_system()
```

### 代码讲解

1. **数据存储**：使用列表`books`存储图书信息，每本书用一个字典表示。
2. **添加图书**：输入书名和作者，存储到列表中。
3. **显示所有图书**：遍历列表并显示所有图书的信息。
4. **查找图书**：根据书名查找图书并显示信息。
5. **删除图书**：根据书名删除图书。
6. **菜单选择**：提供菜单让用户选择添加图书、显示所有图书、查找图书或删除图书。

---


# 编程入门第四天：第一小时

---

## 算法概念与重要性

### 什么是算法？

算法是一组用于解决特定问题的明确指令和步骤。它可以用于数据处理、计算、自动推理和其他任务。一个好的算法通常具有高效性、正确性和可读性。

### 为什么算法重要？

1. **效率**：好的算法能够在较短的时间内处理大量数据，提高程序的运行效率。
2. **解决复杂问题**：通过算法可以将复杂的问题分解为更小、更可管理的问题。
3. **普适性**：算法可以应用于各种领域和问题，具有广泛的应用范围。

---

## 线性查找

### 线性查找的概念

线性查找是一种简单的查找算法，它逐个检查列表中的每个元素，直到找到目标元素或遍历完整个列表。

### 线性查找的实现

```python
def linear_search(arr, target):
    for index, element in enumerate(arr):
        if element == target:
            return index
    return -1
```

### 代码讲解

1. **函数定义**：`linear_search`函数接受一个列表`arr`和一个目标值`target`作为参数。
2. **遍历列表**：使用`enumerate`函数遍历列表，获取每个元素的索引和值。
3. **查找目标值**：如果找到目标值，则返回其索引；否则返回-1。

### 线性查找示例

```python
numbers = [10, 20, 30, 40, 50]
result = linear_search(numbers, 30)
if result != -1:
    print(f"找到目标值，索引为: {result}")
else:
    print("未找到目标值")
```

---

## 二分查找

### 二分查找的概念

二分查找是一种高效的查找算法，适用于已排序的列表。它通过逐步缩小查找范围，将查找范围减半，直到找到目标元素或范围为空。

### 二分查找的实现

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 代码讲解

1. **函数定义**：`binary_search`函数接受一个已排序的列表`arr`和一个目标值`target`作为参数。
2. **初始化边界**：设置左边界`left`为0，右边界`right`为列表长度减1。
3. **查找过程**：使用`while`循环逐步缩小查找范围，直到找到目标值或范围为空。
4. **计算中间索引**：计算当前范围的中间索引`mid`。
5. **比较并调整边界**：根据目标值与中间元素的比较结果调整左边界或右边界。
6. **返回结果**：如果找到目标值，则返回其索引；否则返回-1。

### 二分查找示例

```python
numbers = [10, 20, 30, 40, 50]
result = binary_search(numbers, 30)
if result != -1:
    print(f"找到目标值，索引为: {result}")
else:
    print("未找到目标值")
```

---

## 练习题

### 练习题 1

编写一个程序，使用线性查找算法查找一个列表中的最大值。

#### 示例

```python
def find_max(arr):
    if not arr:
        return None
    max_value = arr[0]
    for element in arr:
        if element > max_value:
            max_value = element
    return max_value

numbers = [10, 20, 30, 40, 50]
max_value = find_max(numbers)
print(f"列表中的最大值是: {max_value}")
```

### 练习题 2

编写一个程序，使用二分查找算法查找一个已排序列表中的目标值，并返回其索引。

#### 示例

```python
numbers = [10, 20, 30, 40, 50]
target = 40
result = binary_search(numbers, target)
if result != -1:
    print(f"找到目标值，索引为: {result}")
else:
    print("未找到目标值")
```

---

## 小结

在这一小时的课程中，我们学习了算法的概念与重要性，并深入了解了线性查找与二分查找两种查找算法。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第四天：第二小时

---

## 排序算法

排序算法是对数据进行排序的算法。在这一小时中，我们将学习三种基本的排序算法：冒泡排序、选择排序和插入排序。

---

## 冒泡排序

### 冒泡排序的概念

冒泡排序是一种简单的排序算法，它重复地遍历列表，通过相邻元素的比较和交换，使得每一趟遍历都将最大（或最小）的元素逐步移动到列表的一端。该算法因为操作类似冒泡而得名。

### 冒泡排序的实现

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

### 代码讲解

1. **外层循环**：控制遍历的趟数。
2. **内层循环**：比较相邻的元素，如果前一个元素大于后一个元素，则交换它们。

### 冒泡排序示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(numbers)
print("排序后的列表:", numbers)
```

---

## 选择排序

### 选择排序的概念

选择排序是一种简单的排序算法。它的工作原理是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

### 选择排序的实现

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
```

### 代码讲解

1. **外层循环**：控制遍历的趟数。
2. **内层循环**：找到当前范围内的最小元素，并将其与范围的起始位置的元素进行交换。

### 选择排序示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
selection_sort(numbers)
print("排序后的列表:", numbers)
```

---

## 插入排序

### 插入排序的概念

插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 插入排序的实现

```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```

### 代码讲解

1. **外层循环**：从第二个元素开始遍历未排序序列。
2. **内层循环**：在已排序序列中从后向前扫描，找到合适的位置插入当前元素。

### 插入排序示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(numbers)
print("排序后的列表:", numbers)
```

---

## 练习题

### 练习题 1

编写一个程序，使用冒泡排序算法对列表进行排序，并返回排序后的列表。

#### 示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(numbers)
print("排序后的列表:", numbers)
```

### 练习题 2

编写一个程序，使用选择排序算法对列表进行排序，并返回排序后的列表。

#### 示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
selection_sort(numbers)
print("排序后的列表:", numbers)
```

### 练习题 3

编写一个程序，使用插入排序算法对列表进行排序，并返回排序后的列表。

#### 示例

```python
numbers = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(numbers)
print("排序后的列表:", numbers)
```

---

## 小结

在这一小时的课程中，我们学习了三种基本的排序算法：冒泡排序、选择排序和插入排序。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第四天：第三小时

---

## 递归概念与简单递归算法

### 什么是递归？

递归是一种解决问题的方法，其中函数直接或间接地调用自身。递归解决问题时，通常将问题分解为一个或多个子问题，每个子问题的结构与原问题相似。

### 递归的基本结构

递归函数通常包含两个部分：
1. **基准情形（Base Case）**：递归终止的条件，当满足该条件时，递归停止。
2. **递归情形（Recursive Case）**：函数自己调用自己，以解决更小的子问题。

### 递归示例：计算阶乘

```python
def factorial(n):
    if n == 0:  # 基准情形，当 n 为 0 时返回 1
        return 1
    else:  # 递归情形，调用自身计算 n * factorial(n - 1)
        return n * factorial(n - 1)
```

### 代码讲解

1. **基准情形**：当`n`为0时，返回1。
2. **递归情形**：调用`factorial(n - 1)`计算`n`的阶乘。

### 递归示例：斐波那契数列

```python
def fibonacci(n):
    if n <= 1:  # 基准情形，当 n 小于等于 1 时返回 n
        return n
    else:  # 递归情形，调用自身计算 fibonacci(n - 1) + fibonacci(n - 2)
        return fibonacci(n - 1) + fibonacci(n - 2)
```

### 代码讲解

1. **基准情形**：当`n`小于或等于1时，返回`n`。
2. **递归情形**：调用`fibonacci(n - 1)`和`fibonacci(n - 2)`计算`n`的斐波那契数。

---

## 列表与元组的使用

### 列表

列表是一种可变的序列，支持多种数据类型，可以存储任意数量的元素。

#### 列表的创建

```python
my_list = [1, 2, 3, 4, 5]
```

#### 列表的基本操作

- **增加元素**：使用`append()`方法在列表末尾添加元素。

  ```python
  my_list.append(6)
  ```

- **删除元素**：使用`remove()`方法删除指定元素，使用`pop()`方法删除指定索引的元素。

  ```python
  my_list.remove(3)
  my_list.pop(2)
  ```

- **修改元素**：直接使用索引修改元素。

  ```python
  my_list[0] = 10
  ```

- **查询元素**：使用索引查询元素，使用`in`关键字判断元素是否存在。

  ```python
  print(my_list[1])
  print(5 in my_list)
  ```

### 元组

元组是一种不可变的序列，一旦创建便不能修改。

#### 元组的创建

```python
my_tuple = (1, 2, 3, 4, 5)
```

#### 元组的基本操作

- **查询元素**：使用索引查询元素，使用`in`关键字判断元素是否存在。

  ```python
  print(my_tuple[1])
  print(5 in my_tuple)
  ```

- **元组不可修改**：尝试修改元组元素会引发错误。

  ```python
  # my_tuple[0] = 10  # 这会引发错误
  ```

---

## 字典与集合的使用

### 字典

字典是一种键值对数据结构，用于存储映射关系。

#### 字典的创建

```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}
```

#### 字典的基本操作

- **增加/修改元素**：通过键增加或修改元素。

  ```python
  my_dict["email"] = "alice@example.com"
  my_dict["age"] = 26
  ```

- **删除元素**：使用`del`关键字删除元素，使用`pop()`方法删除指定键的元素。

  ```python
  del my_dict["city"]
  my_dict.pop("age")
  ```

- **查询元素**：使用键查询元素，使用`in`关键字判断键是否存在。

  ```python
  print(my_dict["name"])
  print("age" in my_dict)
  ```

### 集合

集合是一种无序不重复的元素集合。

#### 集合的创建

```python
my_set = {1, 2, 3, 4, 5}
```

#### 集合的基本操作

- **增加元素**：使用`add()`方法增加元素。

  ```python
  my_set.add(6)
  ```

- **删除元素**：使用`remove()`方法删除指定元素，使用`pop()`方法删除任意元素。

  ```python
  my_set.remove(3)
  my_set.pop()
  ```

- **查询元素**：使用`in`关键字判断元素是否存在。

  ```python
  print(5 in my_set)
  ```

---

## 练习题

### 练习题 1

编写一个递归函数，计算给定整数的阶乘。

#### 示例

```python
def factorial(n):
    if n == 0:  # 基准情形，当 n 为 0 时返回 1
        return 1
    else:  # 递归情形，调用自身计算 n * factorial(n - 1)
        return n * factorial(n - 1)

print(factorial(5))  # 输出: 120
```

### 练习题 2

编写一个递归函数，生成斐波那契数列的第`n`个数。

#### 示例

```python
def fibonacci(n):
    if n <= 1:  # 基准情形，当 n 小于等于 1 时返回 n
        return n
    else:  # 递归情形，调用自身计算 fibonacci(n - 1) + fibonacci(n - 2)
        return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(6))  # 输出: 8
```

### 练习题 3

编写一个程序，使用字典存储学生的信息（姓名、年龄、成绩），并实现增加、删除、修改和查询学生信息的功能。

#### 示例

```python
students = {}

def add_student(name, age, score):
    students[name] = {"age": age, "score": score}

def remove_student(name):
    if name in students:
        del students[name]

def update_student(name, age=None, score=None):
    if name in students:
        if age is not None:
            students[name]["age"] = age
        if score is not None:
            students[name]["score"] = score

def get_student(name):
    return students.get(name)

# 添加学生
add_student("Alice", 20, 90)
add_student("Bob", 21, 85)

# 查询学生
print(get_student("Alice"))  # 输出: {'age': 20, 'score': 90}

# 更新学生
update_student("Alice", score=95)

# 删除学生
remove_student("Bob")

# 最终学生信息
print(students)  # 输出: {'Alice': {'age': 20, 'score': 95}}
```

---

## 小结

在这一小时的课程中，我们学习了递归的概念与简单递归算法、列表与元组的使用及基本操作、字典与集合的使用及基本操作。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第四天：第四小时

---

## 动态规划概念与应用

### 什么是动态规划？

动态规划是一种将复杂问题分解为更小子问题的方法。它通过存储子问题的结果，避免重复计算，从而提高效率。动态规划通常用于解决最优化问题，如最短路径、最大子序列和背包问题。

### 动态规划的基本思想

1. **划分阶段**：将问题划分为一系列子问题。
2. **定义状态**：定义每个子问题的状态。
3. **决策转移**：通过状态转移方程，从已解决的子问题推导出当前子问题的解。
4. **最优解**：通过递推找到最优解。

---

## 简单动态规划问题：斐波那契数列

### 斐波那契数列的动态规划实现

斐波那契数列可以通过动态规划高效地实现，避免递归带来的重复计算。

#### 代码示例

```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

print(fibonacci_dp(10))  # 输出: 55
```

### 代码讲解

1. **初始化**：创建一个数组`dp`来存储斐波那契数列的值，`dp[0]`和`dp[1]`分别初始化为0和1。
2. **状态转移**：通过循环计算`dp[i]`的值，`dp[i]`等于`dp[i - 1]`与`dp[i - 2]`之和。
3. **返回结果**：最后返回`dp[n]`的值。

---

## 贪心算法概念与应用

### 什么是贪心算法？

贪心算法是一种逐步构建解决方案的算法，每一步都做出局部最优的选择，从而希望能得到全局最优解。贪心算法通常用于解决最优化问题，如最小生成树、最短路径和找零问题。

### 贪心算法的基本思想

1. **选择操作**：每一步都选择当前最优的操作。
2. **可行性**：所选操作保证问题的可行性。
3. **最优性**：通过每一步的局部最优选择，最终得到全局最优解。

---

## 简单贪心算法问题：找零问题

### 找零问题的贪心算法实现

找零问题是一个经典的贪心算法问题，目标是用最少的硬币数量凑出指定金额。

#### 代码示例

```python
def min_coins(coins, amount):
    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        while amount >= coin:
            amount -= coin
            count += 1
    return count

coins = [1, 5, 10, 25]
amount = 63
print(min_coins(coins, amount))  # 输出: 6
```

### 代码讲解

1. **排序硬币**：将硬币按面值从大到小排序。
2. **选择硬币**：从最大面值的硬币开始，尽可能多地使用这种硬币，减少待找零的金额。
3. **计数硬币**：每使用一枚硬币，计数加一，直到找零金额为0。

---

## 练习题

### 练习题 1

编写一个动态规划函数，解决0-1背包问题。

#### 示例

```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][capacity]

weights = [1, 2, 3]
values = [6, 10, 12]
capacity = 5
print(knapsack(weights, values, capacity))  # 输出: 22
```

### 练习题 2

编写一个贪心算法函数，解决活动选择问题，选择最多数量的不重叠活动。

#### 示例

```python
def activity_selection(activities):
    activities.sort(key=lambda x: x[1])
    selected = []
    last_end = 0
    for activity in activities:
        if activity[0] >= last_end:
            selected.append(activity)
            last_end = activity[1]
    return selected

activities = [(1, 3), (2, 5), (0, 6), (5, 7), (8, 9), (5, 9)]
print(activity_selection(activities))  # 输出: [(1, 3), (5, 7), (8, 9)]
```

---

## 小结

在这一小时的课程中，我们学习了动态规划和贪心算法的概念与应用，解决了斐波那契数列和找零问题。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第五天：第一小时

---

## 队列

### 队列的概念

队列是一种先进先出（FIFO）的数据结构，元素从队列的一端入队，从另一端出队。

### 队列的基本操作

1. **入队（Enqueue）**：将元素添加到队列末尾。
2. **出队（Dequeue）**：从队列头部移除元素。
3. **队列为空（IsEmpty）**：检查队列是否为空。
4. **队列大小（Size）**：返回队列中的元素数量。

### 队列的实现

#### 代码示例

```python
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 测试队列
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue.dequeue())  # 输出: 1
print(queue.size())  # 输出: 2
```

---

## 堆栈

### 堆栈的概念

堆栈是一种后进先出（LIFO）的数据结构，元素从堆栈的一端压栈，从同一端出栈。

### 堆栈的基本操作

1. **压栈（Push）**：将元素添加到堆栈顶端。
2. **出栈（Pop）**：从堆栈顶端移除元素。
3. **查看栈顶元素（Peek）**：查看堆栈顶端的元素但不移除它。
4. **堆栈为空（IsEmpty）**：检查堆栈是否为空。
5. **堆栈大小（Size）**：返回堆栈中的元素数量。

### 堆栈的实现

#### 代码示例

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def peek(self):
        if not self.is_empty():
            return self.items[-1]

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 测试堆栈
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())  # 输出: 3
print(stack.size())  # 输出: 2
```

---

## 链表

### 链表的概念

链表是一种线性数据结构，其中每个元素是一个节点，每个节点包含数据和指向下一个节点的指针。

### 链表的基本操作

1. **插入（Insert）**：在链表中插入新节点。
2. **删除（Delete）**：从链表中删除指定节点。
3. **查找（Search）**：在链表中查找特定节点。
4. **链表为空（IsEmpty）**：检查链表是否为空。
5. **链表长度（Length）**：返回链表中的节点数量。

### 链表的实现

#### 代码示例

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete(self, key):
        temp = self.head
        if temp is not None:
            if temp.data == key:
                self.head = temp.next
                temp = None
                return
        while temp is not None:
            if temp.data == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None

    def search(self, key):
        current = self.head
        while current is not None:
            if current.data == key:
                return True
            current = current.next
        return False

    def is_empty(self):
        return self.head is None

    def length(self):
        count = 0
        current = self.head
        while current is not None:
            count += 1
            current = current.next
        return count

# 测试链表
linked_list = LinkedList()
linked_list.insert(1)
linked_list.insert(2)
linked_list.insert(3)
print(linked_list.search(2))  # 输出: True
print(linked_list.length())  # 输出: 3
linked_list.delete(2)
print(linked_list.length())  # 输出: 2
```

---

## 练习题

### 练习题 1

实现一个队列，并使用队列模拟银行排队系统，处理客户的到达和离开。

#### 示例

```python
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 模拟银行排队系统
bank_queue = Queue()
bank_queue.enqueue("客户1")
bank_queue.enqueue("客户2")
print(bank_queue.dequeue())  # 输出: 客户1
print(bank_queue.size())  # 输出: 1
```

### 练习题 2

实现一个堆栈，并使用堆栈模拟浏览器的前进和后退功能。

#### 示例

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def peek(self):
        if not self.is_empty():
            return self.items[-1]

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 模拟浏览器前进和后退功能
history = Stack()
history.push("页面1")
history.push("页面2")
history.push("页面3")
print(history.pop())  # 输出: 页面3
print(history.peek())  # 输出: 页面2
```

### 练习题 3

实现一个链表，并使用链表模拟联系人列表，支持添加、删除和查找联系人。

#### 示例

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete(self, key):
        temp = self.head
        if temp is not None:
            if temp.data == key:
                self.head = temp.next
                temp = None
                return
        while temp is not None:
            if temp.data == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None

    def search(self, key):
        current = self.head
        while current is not None:
            if current.data == key:
                return True
            current = current.next
        return False

    def is_empty(self):
        return self.head is None

    def length(self):
        count = 0
        current = self.head
        while current is not None:
            count += 1
            current = current.next
        return count

# 模拟联系人列表
contacts = LinkedList()
contacts.insert("联系人1")
contacts.insert("联系人2")
print(contacts.search("联系人2"))  # 输出: True
print(contacts.length())  # 输出: 2
contacts.delete("联系人2")
print(contacts.length())  # 输出: 1
```

---

## 小结

在这一小时的课程中，我们学习了队列、堆栈和链表的基本操作与应用。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第五天：第二小时

---

## 二叉堆

### 二叉堆的概念

二叉堆是一种完全二叉树，它分为最大堆和最小堆。最大堆中，每个节点的值都大于或等于其子节点的值；最小堆中，每个节点的值都小于或等于其子节点的值。

### 二叉堆的基本操作

1. **插入（Insert）**：在堆的末尾插入新元素，然后上浮到合适位置。
2. **删除最大/最小值（Extract Max/Min）**：将堆顶元素与堆的最后一个元素交换，移除堆顶元素，然后下沉新的堆顶元素到合适位置。
3. **堆化（Heapify）**：调整堆结构以保持堆的性质。

### 最大堆的实现

#### 代码示例

```python
class MaxHeap:
    def __init__(self):
        self.heap = []

    def insert(self, value):
        self.heap.append(value)
        self._heapify_up(len(self.heap) - 1)

    def extract_max(self):
        if len(self.heap) < 1:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] > self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        left = 2 * index + 1
        right = 2 * index + 2
        largest = index
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._heapify_down(largest)

# 测试二叉堆
max_heap = MaxHeap()
max_heap.insert(3)
max_heap.insert(1)
max_heap.insert(6)
max_heap.insert(5)
max_heap.insert(2)
max_heap.insert(4)
print(max_heap.extract_max())  # 输出: 6
print(max_heap.heap)  # 输出: [5, 3, 4, 1, 2]
```

---

## 二叉搜索树

### 二叉搜索树的概念

二叉搜索树（BST）是一种特殊的二叉树，其中每个节点的值都大于其左子树中的所有节点的值，并且小于其右子树中的所有节点的值。

### 二叉搜索树的基本操作

1. **插入（Insert）**：在树中插入新节点。
2. **删除（Delete）**：从树中删除指定节点。
3. **查找（Search）**：在树中查找特定节点。
4. **遍历（Traversal）**：遍历树的所有节点。

### 二叉搜索树的实现

#### 代码示例

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

    def search(self, value):
        return self._search_recursive(self.root, value)

    def _search_recursive(self, node, value):
        if node is None or node.value == value:
            return node
        if value < node.value:
            return self._search_recursive(node.left, value)
        return self._search_recursive(node.right, value)

    def inorder_traversal(self, node):
        if node:
            self.inorder_traversal(node.left)
            print(node.value, end=" ")
            self.inorder_traversal(node.right)

# 测试二叉搜索树
bst = BinarySearchTree()
bst.insert(5)
bst.insert(3)
bst.insert(7)
bst.insert(2)
bst.insert(4)
bst.insert(6)
bst.insert(8)
bst.inorder_traversal(bst.root)  # 输出: 2 3 4 5 6 7 8
print(bst.search(4).value)  # 输出: 4
```

---

## 练习题

### 练习题 1

实现一个二叉堆，并使用二叉堆实现优先队列。

#### 示例

```python
class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, value):
        self.heap.append(value)
        self._heapify_up(len(self.heap) - 1)

    def extract_max(self):
        if len(self.heap) < 1:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] > self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        left = 2 * index + 1
        right = 2 * index + 2
        largest = index
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._heapify_down(largest)

# 测试优先队列
pq = PriorityQueue()
pq.insert(3)
pq.insert(1)
pq.insert(6)
pq.insert(5)
pq.insert(2)
pq.insert(4)
print(pq.extract_max())  # 输出: 6
print(pq.heap)  # 输出: [5, 3, 4, 1, 2]
```

### 练习题 2

实现一个二叉搜索树，并编写一个方法，找到树中的最小值和最大值。

#### 示例

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if his.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

    def find_min(self):
        current = self.root
        while current.left is not None:
            current = current.left
        return current.value

    def find_max(self):
        current = self.root
        while current.right is not None:
            current = current.right
        return current.value

# 测试二叉搜索树
bst = BinarySearchTree()
bst.insert(5)
bst.insert(3)
bst.insert(7)
bst.insert(2)
bst.insert(4)
bst.insert(6)
bst.insert(8)
print(bst.find_min())  # 输出: 2
print(bst.find_max())  # 输出: 8
```

---

## 小结

在这一小时的课程中，我们学习了二叉堆和二叉搜索树的基本操作与应用。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第五天：第三小时

---

## 哈希值

### 哈希值的概念

哈希值是一种通过哈希函数从输入数据计算出的固定长度的值。哈希值通常用于快速查找数据，以实现高效的插入、删除和查找操作。

### 哈希函数

哈希函数是将输入数据转换为哈希值的函数。理想的哈希函数应该尽可能均匀地分布哈希值，以避免哈希冲突（即不同的输入数据产生相同的哈希值）。

### 常见的哈希函数

常见的哈希函数有MD5、SHA-1和SHA-256等。Python内置的`hash()`函数可以用于生成哈希值。

#### 代码示例

```python
print(hash("hello"))  # 输出: 哈希值（具体值因环境而异）
```

---

## 哈希表

### 哈希表的概念

哈希表是一种基于哈希函数的数据结构，它能够在常数时间内完成插入、删除和查找操作。哈希表使用哈希函数将键映射到存储桶或槽位。

### 哈希表的基本操作

1. **插入（Insert）**：在哈希表中插入键值对。
2. **删除（Delete）**：从哈希表中删除指定键。
3. **查找（Search）**：在哈希表中查找特定键的值。

### 哈希表的实现

#### 代码示例

```python
class HashTable:
    def __init__(self):
        self.size = 10
        self.table = [[] for _ in range(self.size)]

    def hash_function(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        hash_key = self.hash_function(key)
        key_exists = False
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            bucket[i] = (key, value)
        else:
            bucket.append((key, value))

    def delete(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                del bucket[i]

    def search(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for k, v in bucket:
            if key == k:
                return v
        return None

# 测试哈希表
hash_table = HashTable()
hash_table.insert("name", "Alice")
hash_table.insert("age", 25)
print(hash_table.search("name"))  # 输出: Alice
hash_table.delete("age")
print(hash_table.search("age"))  # 输出: None
```

---

## 电话簿的查找与排序

### 实现电话簿的查找与排序

#### 代码示例

```python
class HashTable:
    def __init__(self):
        self.size = 10
        self.table = [[] for _ in range(self.size)]

    def hash_function(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        hash_key = self.hash_function(key)
        key_exists = False
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            bucket[i] = (key, value)
        else:
            bucket.append((key, value))

    def delete(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                del bucket[i]

    def search(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for k, v in bucket:
            if key == k:
                return v
        return None

    def get_all_contacts(self):
        contacts = []
        for bucket in self.table:
            for k, v in bucket:
                contacts.append((k, v))
        return contacts

    def sort_contacts(self):
        contacts = self.get_all_contacts()
        contacts.sort(key=lambda x: x[0])
        return contacts

# 测试电话簿
phone_book = HashTable()
phone_book.insert("Alice", "123456789")
phone_book.insert("Bob", "987654321")
phone_book.insert("Charlie", "555555555")
print(phone_book.search("Alice"))  # 输出: 123456789
phone_book.delete("Bob")
print(phone_book.search("Bob"))  # 输出: None
print(phone_book.sort_contacts())  # 输出: [('Alice', '123456789'), ('Charlie', '555555555')]
```

---

## 练习题

### 练习题 1

实现一个哈希表，并使用哈希表实现一个简单的学生成绩管理系统，支持添加、删除和查找学生成绩，并根据学生姓名排序。

#### 示例

```python
class HashTable:
    def __init__(self):
        self.size = 10
        self.table = [[] for _ in range(self.size)]

    def hash_function(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        hash_key = self.hash_function(key)
        key_exists = False
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            bucket[i] = (key, value)
        else:
            bucket.append((key, value))

    def delete(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for i, kv in enumerate(bucket):
            k, v = kv
            if key == k:
                del bucket[i]

    def search(self, key):
        hash_key = self.hash_function(key)
        bucket = self.table[hash_key]
        for k, v in bucket:
            if key == k:
                return v
        return None

    def get_all_students(self):
        students = []
        for bucket in self.table:
            for k, v in bucket:
                students.append((k, v))
        return students

    def sort_students(self):
        students = self.get_all_students()
        students.sort(key=lambda x: x[0])
        return students

# 测试学生成绩管理系统
grades = HashTable()
grades.insert("Alice", 90)
grades.insert("Bob", 85)
grades.insert("Charlie", 95)
print(grades.search("Alice"))  # 输出: 90
grades.delete("Bob")
print(grades.search("Bob"))  # 输出: None
print(grades.sort_students())  # 输出: [('Alice', 90), ('Charlie', 95)]
```

---

## 小结

在这一小时的课程中，我们学习了哈希值和哈希表的概念与实现，如何实现一个电话簿的查找与排序。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第五天：第四小时

---

## 图算法基础

### 图的表示

图是一种由节点（顶点）和连接这些节点的边构成的数据结构。图可以是有向图或无向图，有权图或无权图。

### 图的表示方法

1. **邻接矩阵**：使用一个二维数组表示图，其中`matrix[i][j]`表示从节点`i`到节点`j`的边。
2. **邻接表**：使用一个数组加链表表示图，其中`list[i]`包含所有与节点`i`相连的节点。

#### 邻接矩阵示例

```python
# 邻接矩阵表示法
adj_matrix = [
    [0, 1, 0, 0],
    [1, 0, 1, 1],
    [0, 1, 0, 1],
    [0, 1, 1, 0]
]
```

#### 邻接表示例

```python
# 邻接表表示法
adj_list = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
```

---

## 深度优先搜索（DFS）

### DFS的概念

深度优先搜索是一种用于遍历或搜索图的算法，从起始节点开始，沿着一个分支走到底，然后回溯，继续搜索其他分支。

### DFS的实现

#### 代码示例

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=" ")
    for next_node in graph[start]:
        if next_node not in visited:
            dfs(graph, next_node, visited)

# 测试DFS
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
dfs(graph, 0)  # 输出: 0 1 2 3
```

---

## 广度优先搜索（BFS）

### BFS的概念

广度优先搜索是一种用于遍历或搜索图的算法，从起始节点开始，首先访问所有相邻节点，然后依次访问这些相邻节点的相邻节点，直到所有节点都被访问。

### BFS的实现

#### 代码示例

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for next_node in graph[node]:
            if next_node not in visited:
                visited.add(next_node)
                queue.append(next_node)

# 测试BFS
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
bfs(graph, 0)  # 输出: 0 1 2 3
```

---

## 练习题

### 练习题 1

编写一个程序，使用DFS遍历一个无向图，并输出每个节点的访问顺序。

#### 示例

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=" ")
    for next_node in graph[start]:
        if next_node not in visited:
            dfs(graph, next_node, visited)

# 测试DFS
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1, 4],
    4: [2, 3]
}
dfs(graph, 0)  # 输出: 0 1 3 4 2
```

### 练习题 2

编写一个程序，使用BFS遍历一个无向图，并输出每个节点的访问顺序。

#### 示例

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for next_node in graph[node]:
            if next_node not in visited:
                visited.add(next_node)
                queue.append(next_node)

# 测试BFS
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1, 4],
    4: [2, 3]
}
bfs(graph, 0)  # 输出: 0 1 2 3 4
```

---

## 小结

在这一小时的课程中，我们学习了图算法的基础知识，了解了图的表示方法，并实现了深度优先搜索（DFS）和广度优先搜索（BFS）算法。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第六天：第一小时

---

## 图算法深入学习

### 图遍历

图遍历是图算法中的基本操作，用于访问图中的所有节点。常见的图遍历算法有深度优先搜索（DFS）和广度优先搜索（BFS）。

### 深度优先搜索（DFS）

深度优先搜索是一种递归算法，从起始节点开始，沿着一个分支走到底，然后回溯，继续搜索其他分支。

#### 代码示例

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=" ")
    for next_node in graph[start]:
        if next_node not in visited:
            dfs(graph, next_node, visited)

# 测试DFS
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
dfs(graph, 0)  # 输出: 0 1 2 3
```

### 广度优先搜索（BFS）

广度优先搜索是一种迭代算法，从起始节点开始，首先访问所有相邻节点，然后依次访问这些相邻节点的相邻节点，直到所有节点都被访问。

#### 代码示例

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for next_node in graph[node]:
            if next_node not in visited:
                visited.add(next_node)
                queue.append(next_node)

# 测试BFS
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
bfs(graph, 0)  # 输出: 0 1 2 3
```

---

## 最短路径

最短路径问题是图论中的经典问题之一，旨在找到从起始节点到目标节点的最短路径。常见的最短路径算法有Dijkstra算法和Bellman-Ford算法。

### Dijkstra算法

Dijkstra算法是一种基于贪心思想的最短路径算法，适用于无负权边的图。它通过逐步扩展最短路径树，找到从起始节点到所有其他节点的最短路径。

#### 代码示例

```python
import heapq

def dijkstra(graph, start):
    heap = [(0, start)]
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    while heap:
        current_distance, current_node = heapq.heappop(heap)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(heap, (distance, neighbor))
    return distances

# 测试Dijkstra算法
graph = {
    0: [(1, 1), (2, 4)],
    1: [(0, 1), (2, 2), (3, 5)],
    2: [(0, 4), (1, 2), (3, 1)],
    3: [(1, 5), (2, 1)]
}
print(dijkstra(graph, 0))  # 输出: {0: 0, 1: 1, 2: 3, 3: 4}
```

---

## 循环检测

循环检测是图算法中的一个重要问题，用于检测图中是否存在环。常见的循环检测算法有DFS循环检测和并查集循环检测。

### DFS循环检测

DFS循环检测通过在DFS过程中记录当前路径上的节点，检测到已经在当前路径上的节点则说明存在环。

#### 代码示例

```python
def dfs_cycle(graph, node, visited, stack):
    visited.add(node)
    stack.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            if dfs_cycle(graph, neighbor, visited, stack):
                return True
        elif neighbor in stack:
            return True
    stack.remove(node)
    return False

def has_cycle(graph):
    visited = set()
    stack = set()
    for node in graph:
        if node not in visited:
            if dfs_cycle(graph, node, visited, stack):
                return True
    return False

# 测试循环检测
graph = {
    0: [1, 2],
    1: [2],
    2: [0, 3],
    3: [3]
}
print(has_cycle(graph))  # 输出: True
```

---

## 练习题

### 练习题 1

编写一个程序，使用Dijkstra算法计算一个加权无向图中每个节点到起始节点的最短路径。

#### 示例

```python
import heapq

def dijkstra(graph, start):
    heap = [(0, start)]
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    while heap:
        current_distance, current_node = heapq.heappop(heap)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(heap, (distance, neighbor))
    return distances

# 测试Dijkstra算法
graph = {
    0: [(1, 1), (2, 4)],
    1: [(0, 1), (2, 2), (3, 5)],
    2: [(0, 4), (1, 2), (3, 1)],
    3: [(1, 5), (2, 1)]
}
print(dijkstra(graph, 0))  # 输出: {0: 0, 1: 1, 2: 3, 3: 4}
```

### 练习题 2

编写一个程序，检测一个无向图中是否存在环。

#### 示例

```python
def dfs_cycle(graph, node, visited, stack):
    visited.add(node)
    stack.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            if dfs_cycle(graph, neighbor, visited, stack):
                return True
        elif neighbor in stack:
            return True
    stack.remove(node)
    return False

def has_cycle(graph):
    visited = set()
    stack = set()
    for node in graph:
        if node not in visited:
            if dfs_cycle(graph, node, visited, stack):
                return True
    return False

# 测试循环检测
graph = {
    0: [1, 2],
    1: [2],
    2: [0, 3],
    3: [3]
}
print(has_cycle(graph))  # 输出: True
```

---

## 小结

在这一小时的课程中，我们深入学习了图算法，包括图遍历、最短路径和循环检测。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第六天：第二小时

---

## Numpy基础

Numpy是Python中一个强大的科学计算库，用于处理大型多维数组和矩阵运算。Numpy提供了丰富的数学函数库，便于进行快速数组计算。

### 数组创建与操作

#### 创建数组

```python
import numpy as np

# 创建一维数组
a = np.array([1, 2, 3, 4, 5])
print(a)

# 创建二维数组
b = np.array([[1, 2, 3], [4, 5, 6]])
print(b)

# 创建全零数组
c = np.zeros((3, 4))
print(c)

# 创建全一数组
d = np.ones((2, 3))
print(d)

# 创建指定值的数组
e = np.full((2, 2), 7)
print(e)

# 创建单位矩阵
f = np.eye(3)
print(f)

# 创建随机数组
g = np.random.random((2, 2))
print(g)
```

#### 数组操作

```python
# 数组形状
print(a.shape)
print(b.shape)

# 数组重塑
h = np.reshape(a, (5, 1))
print(h)

# 数组拼接
i = np.concatenate((a, a))
print(i)

# 数组切片
print(a[1:4])
print(b[:, 1:3])
```

### 基本运算

```python
# 数组加法
j = np.array([10, 20, 30, 40, 50])
print(a + j)

# 数组减法
print(a - j)

# 数组乘法
print(a * j)

# 数组除法
print(a / j)

# 数组点积
k = np.array([[1, 2], [3, 4]])
l = np.array([[5, 6], [7, 8]])
print(np.dot(k, l))

# 数组求和
print(np.sum(a))

# 数组最大值
print(np.max(a))

# 数组最小值
print(np.min(a))

# 数组平均值
print(np.mean(a))
```

---

## Pandas基础

Pandas是Python中一个强大的数据分析和数据处理库。Pandas提供了高效地操作大型数据集的工具，尤其适用于结构化数据。

### 数据结构（Series, DataFrame）

#### Series

Series是一种类似于一维数组的对象，它由一组数据和一组与之相关的数据标签（即索引）组成。

```python
import pandas as pd

# 创建Series
s = pd.Series([1, 3, 5, np.nan, 6, 8])
print(s)

# 带索引的Series
s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
print(s)
```

#### DataFrame

DataFrame是一个二维的、带标签的数据结构，类似于电子表格或SQL表。

```python
# 创建DataFrame
data = {
    'Name': ['Alice', 'Bob', 'Charlie', 'David'],
    'Age': [24, 27, 22, 32],
    'City': ['New York', 'Los Angeles', 'Chicago', 'Houston']
}
df = pd.DataFrame(data)
print(df)

# 从字典创建DataFrame
df = pd.DataFrame({
    'A': 1.,
    'B': pd.Timestamp('20230101'),
    'C': pd.Series(1, index=list(range(4)), dtype='float32'),
    'D': np.array([3] * 4, dtype='int32'),
    'E': pd.Categorical(['test', 'train', 'test', 'train']),
    'F': 'foo'
})
print(df)
```

### 数据导入与导出

#### 导入数据

```python
# 从CSV文件导入数据
df = pd.read_csv('data.csv')
print(df)

# 从Excel文件导入数据
df = pd.read_excel('data.xlsx', sheet_name='Sheet1')
print(df)

# 从SQL数据库导入数据
import sqlite3
conn = sqlite3.connect('data.db')
df = pd.read_sql_query('SELECT * FROM table_name', conn)
print(df)
```

#### 导出数据

```python
# 导出数据到CSV文件
df.to_csv('output.csv', index=False)

# 导出数据到Excel文件
df.to_excel('output.xlsx', sheet_name='Sheet1', index=False)

# 导出数据到SQL数据库
conn = sqlite3.connect('output.db')
df.to_sql('table_name', conn, if_exists='replace', index=False)
```

---

## 小结

在这一小时的课程中，我们学习了Numpy和Pandas的基础知识，包括数组创建与操作、基本运算，数据结构（Series, DataFrame）以及数据导入与导出。通过这些知识，我们可以高效地处理和分析数据。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第六天：第三小时

---

## 数据清洗与处理

数据清洗是数据分析过程中非常重要的一步。它包括处理缺失值、去除重复数据、数据格式转换等。

### 缺失值处理

处理缺失值是数据清洗的一个重要环节。在Pandas中，可以使用`isnull()`和`dropna()`等方法来处理缺失值。

#### 检查缺失值

```python
import pandas as pd
import numpy as np

data = {
    'A': [1, 2, np.nan, 4, 5],
    'B': [np.nan, 2, 3, np.nan, 5],
    'C': [1, 2, 3, 4, 5]
}
df = pd.DataFrame(data)
print(df)

# 检查缺失值
print(df.isnull())
print(df.isnull().sum())
```

#### 删除缺失值

```python
# 删除有缺失值的行
df_dropna = df.dropna()
print(df_dropna)

# 删除有缺失值的列
df_dropna_col = df.dropna(axis=1)
print(df_dropna_col)
```

#### 填充缺失值

```python
# 使用指定值填充缺失值
df_fillna = df.fillna(0)
print(df_fillna)

# 使用均值填充缺失值
df_fillna_mean = df.fillna(df.mean())
print(df_fillna_mean)
```

---

## 数据分析与处理

数据分析是从数据中提取有用信息的过程。Pandas提供了丰富的数据分析工具，可以对数据进行各种统计分析和处理。

### 基本统计分析

```python
# 读取数据
df = pd.DataFrame(data)

# 描述性统计
print(df.describe())

# 计算每列的均值
print(df.mean())

# 计算每列的中位数
print(df.median())

# 计算每列的标准差
print(df.std())
```

### 数据分组与聚合

```python
# 创建示例数据
data = {
    'Category': ['A', 'A', 'B', 'B', 'C', 'C'],
    'Values': [1, 2, 3, 4, 5, 6]
}
df = pd.DataFrame(data)

# 数据分组
grouped = df.groupby('Category')

# 计算分组后的均值
print(grouped.mean())

# 计算分组后的总和
print(grouped.sum())
```

### 数据透视表

```python
# 创建示例数据
data = {
    'A': ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'],
    'B': ['one', 'one', 'two', 'two', 'one', 'one'],
    'C': ['small', 'large', 'large', 'small', 'small', 'large'],
    'D': [1, 2, 2, 3, 3, 4]
}
df = pd.DataFrame(data)

# 创建数据透视表
pivot_table = pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C'], aggfunc=np.sum)
print(pivot_table)
```

---

## 代码讲解与问题解答

在本节中，我们将通过一个示例项目来应用所学的知识，处理一个实际数据集并进行分析。

### 示例项目：分析销售数据

#### 读取数据

```python
# 读取CSV文件
sales_data = pd.read_csv('sales_data.csv')
print(sales_data.head())
```

#### 检查和处理缺失值

```python
# 检查缺失值
print(sales_data.isnull().sum())

# 删除缺失值
sales_data = sales_data.dropna()
print(sales_data.isnull().sum())
```

#### 数据分析

```python
# 描述性统计
print(sales_data.describe())

# 按产品类别分组并计算总销售额
grouped_sales = sales_data.groupby('Product Category')['Sales'].sum()
print(grouped_sales)

# 创建数据透视表，按月份和产品类别计算销售额
pivot_sales = pd.pivot_table(sales_data, values='Sales', index='Month', columns='Product Category', aggfunc=np.sum)
print(pivot_sales)
```

---

## 练习题

### 练习题 1

读取一个包含学生成绩的数据集，检查并处理缺失值，计算每个学生的总成绩和平均成绩，并按班级分组计算班级的平均成绩。

#### 示例代码

```python
# 创建示例数据
data = {
    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],
    'Class': ['A', 'B', 'A', 'B', 'A'],
    'Math': [85, 78, np.nan, 92, 88],
    'English': [90, 88, 85, np.nan, 95],
    'Science': [np.nan, 80, 85, 88, 90]
}
df = pd.DataFrame(data)

# 检查缺失值
print(df.isnull().sum())

# 使用均值填充缺失值
df = df.fillna(df.mean())
print(df)

# 计算总成绩和平均成绩
df['Total'] = df['Math'] + df['English'] + df['Science']
df['Average'] = df['Total'] / 3
print(df)

# 按班级分组计算平均成绩
class_grouped = df.groupby('Class')['Average'].mean()
print(class_grouped)
```

---

## 小结

在这一小时的课程中，我们学习了数据清洗与处理、缺失值处理、数据分析与处理的方法，并通过示例项目进行实践。最后，通过练习题巩固所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第六天：第四小时

---

## Math库基础

Python中的math库提供了丰富的数学函数，用于执行基本的数学运算。

### 常用数学函数

#### 代码示例

```python
import math

# 计算平方根
print(math.sqrt(16))  # 输出: 4.0

# 计算幂
print(math.pow(2, 3))  # 输出: 8.0

# 计算对数
print(math.log(10))  # 输出: 2.302585092994046
print(math.log(10, 2))  # 输出: 3.321928094887362

# 计算三角函数
print(math.sin(math.pi / 2))  # 输出: 1.0
print(math.cos(math.pi))  # 输出: -1.0
print(math.tan(math.pi / 4))  # 输出: 1.0

# 计算阶乘
print(math.factorial(5))  # 输出: 120

# 四舍五入
print(math.ceil(4.2))  # 输出: 5
print(math.floor(4.8))  # 输出: 4
```

---

## Random库基础

Python中的random库提供了生成随机数的函数，可用于模拟随机事件。

### 随机数生成与应用

#### 代码示例

```python
import random

# 生成0到1之间的随机浮点数
print(random.random())  # 输出: 0.37444887175646646

# 生成指定范围内的随机整数
print(random.randint(1, 10))  # 输出: 7

# 从指定范围内按步长生成随机整数
print(random.randrange(0, 101, 10))  # 输出: 50

# 从列表中随机选择一个元素
choices = ['apple', 'banana', 'cherry']
print(random.choice(choices))  # 输出: 'banana'

# 打乱列表顺序
random.shuffle(choices)
print(choices)  # 输出: ['cherry', 'banana', 'apple']

# 生成指定数量的随机样本
print(random.sample(range(100), 5))  # 输出: [84, 12, 31, 56, 74]
```

---

## 综合应用：模拟随机事件

我们将使用random库模拟一个抛硬币的事件，并计算出现正面和反面的概率。

#### 代码示例

```python
import random

def coin_toss(n):
    heads = 0
    tails = 0
    for _ in range(n):
        if random.random() < 0.5:
            heads += 1
        else:
            tails += 1
    return heads, tails

# 模拟1000次抛硬币
n = 1000
heads, tails = coin_toss(n)
print(f'正面: {heads}, 反面: {tails}')
print(f'正面概率: {heads/n}, 反面概率: {tails/n}')
```

---

## 项目练习：随机数模拟与分析

### 项目描述

编写一个程序，模拟掷骰子1000次，记录每个数字出现的次数，并分析结果。

#### 代码示例

```python
import random
import matplotlib.pyplot as plt

def roll_dice(n):
    results = [0] * 6
    for _ in range(n):
        roll = random.randint(1, 6)
        results[roll - 1] += 1
    return results

# 模拟1000次掷骰子
n = 1000
results = roll_dice(n)

# 打印结果
for i in range(6):
    print(f'{i + 1} 点出现的次数: {results[i]}')

# 绘制结果条形图
labels = ['1', '2', '3', '4', '5', '6']
plt.bar(labels, results)
plt.xlabel('点数')
plt.ylabel('出现次数')
plt.title('掷骰子结果')
plt.show()
```

---

## 小结

在这一小时的课程中，我们学习了Math库和Random库的基础知识，包括常用数学函数、随机数生成与应用，并通过综合应用和项目练习进行实践。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第七天：第一小时

---

## Matplotlib基础

Matplotlib是Python中最常用的绘图库之一，它提供了一整套绘图功能，可以用来生成各种图表和图形。

### 安装Matplotlib

如果还没有安装Matplotlib，可以使用以下命令进行安装：

```sh
pip install matplotlib
```

### 导入Matplotlib

在开始绘图之前，需要先导入Matplotlib库中的`pyplot`模块：

```python
import matplotlib.pyplot as plt
```

---

## 基本图形绘制

### 折线图

折线图用于显示数据的变化趋势。以下是一个简单的折线图示例：

```python
import matplotlib.pyplot as plt

# 数据
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

# 绘制折线图
plt.plot(x, y)

# 添加标题和标签
plt.title("折线图示例")
plt.xlabel("X轴标签")
plt.ylabel("Y轴标签")

# 显示图形
plt.show()
```

### 柱状图

柱状图用于比较不同类别的数据。以下是一个简单的柱状图示例：

```python
import matplotlib.pyplot as plt

# 数据
categories = ['A', 'B', 'C', 'D']
values = [3, 7, 5, 6]

# 绘制柱状图
plt.bar(categories, values)

# 添加标题和标签
plt.title("柱状图示例")
plt.xlabel("类别")
plt.ylabel("值")

# 显示图形
plt.show()
```

### 散点图

散点图用于显示数据点的分布情况。以下是一个简单的散点图示例：

```python
import matplotlib.pyplot as plt

# 数据
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

# 绘制散点图
plt.scatter(x, y)

# 添加标题和标签
plt.title("散点图示例")
plt.xlabel("X轴标签")
plt.ylabel("Y轴标签")

# 显示图形
plt.show()
```

---

## 练习题

### 练习题 1

使用Matplotlib绘制一个包含以下数据的折线图，并为图形添加标题和标签：

- X轴数据：`[0, 1, 2, 3, 4, 5]`
- Y轴数据：`[0, 1, 4, 9, 16, 25]`

#### 示例代码

```python
import matplotlib.pyplot as plt

# 数据
x = [0, 1, 2, 3, 4, 5]
y = [0, 1, 4, 9, 16, 25]

# 绘制折线图
plt.plot(x, y)

# 添加标题和标签
plt.title("折线图练习")
plt.xlabel("X轴")
plt.ylabel("Y轴")

# 显示图形
plt.show()
```

### 练习题 2

使用Matplotlib绘制一个包含以下数据的柱状图，并为图形添加标题和标签：

- 类别：`['Category 1', 'Category 2', 'Category 3', 'Category 4']`
- 值：`[10, 20, 15, 25]`

#### 示例代码

```python
import matplotlib.pyplot as plt

# 数据
categories = ['Category 1', 'Category 2', 'Category 3', 'Category 4']
values = [10, 20, 15, 25]

# 绘制柱状图
plt.bar(categories, values)

# 添加标题和标签
plt.title("柱状图练习")
plt.xlabel("类别")
plt.ylabel("值")

# 显示图形
plt.show()
```

### 练习题 3

使用Matplotlib绘制一个包含以下数据的散点图，并为图形添加标题和标签：

- X轴数据：`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
- Y轴数据：`[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

#### 示例代码

```python
import matplotlib.pyplot as plt

# 数据
x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

# 绘制散点图
plt.scatter(x, y)

# 添加标题和标签
plt.title("散点图练习")
plt.xlabel("X轴")
plt.ylabel("Y轴")

# 显示图形
plt.show()
```

---

## 小结

在这一小时的课程中，我们学习了Matplotlib的基础知识，包括基本图形的绘制（折线图、柱状图、散点图）。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第七天：第二小时

---

## 高级图形绘制

在这一小时中，我们将学习如何使用Matplotlib绘制高级图形，如热力图、箱线图和直方图。

### 热力图

热力图是一种矩阵图，用于表示数据值的大小。颜色的深浅表示数据值的大小。

#### 代码示例

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.rand(10, 10)

# 绘制热力图
plt.imshow(data, cmap='hot', interpolation='nearest')

# 添加颜色条
plt.colorbar()

# 添加标题
plt.title("热力图示例")

# 显示图形
plt.show()
```

### 箱线图

箱线图用于显示数据的分布情况，包括最小值、第一四分位数、中位数、第三四分位数和最大值。

#### 代码示例

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.randn(100)

# 绘制箱线图
plt.boxplot(data)

# 添加标题
plt.title("箱线图示例")

# 显示图形
plt.show()
```

### 直方图

直方图用于显示数据的频率分布情况。它将数据分成若干个区间，然后统计每个区间的数据数量。

#### 代码示例

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.randn(1000)

# 绘制直方图
plt.hist(data, bins=30, alpha=0.75, color='blue')

# 添加标题和标签
plt.title("直方图示例")
plt.xlabel("值")
plt.ylabel("频率")

# 显示图形
plt.show()
```

---

## 练习题

### 练习题 1

使用Matplotlib绘制一个包含以下数据的热力图，并为图形添加标题：

- 数据：生成一个5x5的随机矩阵

#### 示例代码

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.rand(5, 5)

# 绘制热力图
plt.imshow(data, cmap='viridis', interpolation='nearest')

# 添加颜色条
plt.colorbar()

# 添加标题
plt.title("热力图练习")

# 显示图形
plt.show()
```

### 练习题 2

使用Matplotlib绘制一个包含以下数据的箱线图，并为图形添加标题：

- 数据：生成100个随机数，均值为0，标准差为1

#### 示例代码

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.randn(100)

# 绘制箱线图
plt.boxplot(data)

# 添加标题
plt.title("箱线图练习")

# 显示图形
plt.show()
```

### 练习题 3

使用Matplotlib绘制一个包含以下数据的直方图，并为图形添加标题和标签：

- 数据：生成1000个随机数，均值为0，标准差为1
- 直方图的区间数量：20

#### 示例代码

```python
import matplotlib.pyplot as plt
import numpy as np

# 数据
data = np.random.randn(1000)

# 绘制直方图
plt.hist(data, bins=20, alpha=0.75, color='green')

# 添加标题和标签
plt.title("直方图练习")
plt.xlabel("值")
plt.ylabel("频率")

# 显示图形
plt.show()
```

---

## 小结

在这一小时的课程中，我们学习了如何使用Matplotlib绘制高级图形，包括热力图、箱线图和直方图。通过练习题，我们进一步巩固了所学的知识。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第七天：第三小时

---

## 项目练习：数据可视化项目

在这一小时中，我们将进行一个综合性的项目练习，使用之前学到的Matplotlib绘图技术对一个数据集进行可视化分析。

### 项目描述

我们将使用一个包含学生考试成绩的数据集，进行以下可视化分析：

1. 绘制每个学生的总成绩折线图
2. 绘制各科成绩的箱线图
3. 绘制总成绩的直方图
4. 绘制各科成绩的热力图

### 数据准备

假设我们的数据集`student_scores.csv`包含以下列：
- `Name`：学生姓名
- `Math`：数学成绩
- `English`：英语成绩
- `Science`：科学成绩

#### 示例数据

```plaintext
Name,Math,English,Science
Alice,85,78,92
Bob,90,88,80
Charlie,70,85,85
David,88,92,90
Eve,95,91,94
```

### 代码讲解与示例

#### 1. 绘制每个学生的总成绩折线图

```python
import pandas as pd
import matplotlib.pyplot as plt

# 读取数据
df = pd.read_csv('student_scores.csv')

# 计算总成绩
df['Total'] = df['Math'] + df['English'] + df['Science']

# 绘制折线图
plt.plot(df['Name'], df['Total'], marker='o')

# 添加标题和标签
plt.title('学生总成绩折线图')
plt.xlabel('学生姓名')
plt.ylabel('总成绩')

# 显示图形
plt.show()
```

#### 2. 绘制各科成绩的箱线图

```python
# 数据准备
data = [df['Math'], df['English'], df['Science']]

# 绘制箱线图
plt.boxplot(data, labels=['Math', 'English', 'Science'])

# 添加标题
plt.title('各科成绩箱线图')

# 显示图形
plt.show()
```

#### 3. 绘制总成绩的直方图

```python
# 绘制直方图
plt.hist(df['Total'], bins=5, alpha=0.75, color='blue')

# 添加标题和标签
plt.title('总成绩直方图')
plt.xlabel('总成绩')
plt.ylabel('频率')

# 显示图形
plt.show()
```

#### 4. 绘制各科成绩的热力图

```python
import numpy as np

# 数据准备
scores = df[['Math', 'English', 'Science']].to_numpy()

# 绘制热力图
plt.imshow(scores, cmap='viridis', interpolation='nearest', aspect='auto')

# 添加颜色条
plt.colorbar()

# 添加标题和标签
plt.title('各科成绩热力图')
plt.xticks(np.arange(3), ['Math', 'English', 'Science'])
plt.yticks(np.arange(len(df['Name'])), df['Name'])

# 显示图形
plt.show()
```

---

## 问题解答

1. **如何调整图形的大小和分辨率？**
   可以使用`plt.figure()`函数调整图形的大小和分辨率，例如：
   ```python
   plt.figure(figsize=(10, 6), dpi=80)
   ```

2. **如何保存图形到文件？**
   可以使用`plt.savefig()`函数将图形保存为文件，例如：
   ```python
   plt.savefig('figure.png')
   ```

3. **如何在一个图中绘制多个子图？**
   可以使用`plt.subplot()`函数在一个图中绘制多个子图，例如：
   ```python
   plt.subplot(2, 1, 1)
   plt.plot(x, y1)
   plt.subplot(2, 1, 2)
   plt.plot(x, y2)
   ```

---

## 小结

在这一小时的课程中，我们通过一个综合性的项目练习，使用Matplotlib对一个数据集进行了可视化分析。通过这个项目，我们巩固了之前学到的绘图技术，并学会了如何在实际应用中进行数据可视化。接下来我们将继续学习更多的编程知识，敬请期待！

---


# 编程入门第七天：第四小时

---

## 综合项目：从数据处理到可视化

在这一小时中，我们将进行一个综合性的项目练习，结合数据处理和可视化技术，对一个完整的数据集进行处理和分析，并生成各种图表。

### 项目描述

我们将使用一个包含全球各国人口数据的数据集，进行以下步骤的分析和可视化：

1. 数据读取与初步检查
2. 数据清洗与处理
3. 数据分析与统计
4. 数据可视化

### 数据准备

假设我们的数据集`world_population.csv`包含以下列：
- `Country`：国家名称
- `Year`：年份
- `Population`：人口数量

#### 示例数据

```plaintext
Country,Year,Population
China,2020,1444216107
India,2020,1393409038
United States,2020,331002651
Indonesia,2020,273523615
Pakistan,2020,220892340
...
```

### 代码讲解与示例

#### 1. 数据读取与初步检查

```python
import pandas as pd

# 读取数据
df = pd.read_csv('world_population.csv')

# 显示前几行数据
print(df.head())

# 检查数据类型和缺失值
print(df.info())
print(df.isnull().sum())
```

#### 2. 数据清洗与处理

```python
# 删除缺失值
df = df.dropna()

# 将年份转换为整数
df['Year'] = df['Year'].astype(int)

# 选择2020年的数据
df_2020 = df[df['Year'] == 2020]

# 按人口数量排序
df_2020 = df_2020.sort_values(by='Population', ascending=False)

# 选择前10个国家
top_10_countries = df_2020.head(10)
print(top_10_countries)
```

#### 3. 数据分析与统计

```python
# 计算总人口
total_population = df_2020['Population'].sum()
print(f'2020年全球总人口: {total_population}')

# 计算各国人口占比
top_10_countries['Population_Percentage'] = (top_10_countries['Population'] / total_population) * 100
print(top_10_countries[['Country', 'Population_Percentage']])
```

#### 4. 数据可视化

##### 4.1 绘制前10个国家的人口柱状图

```python
import matplotlib.pyplot as plt

# 绘制柱状图
plt.bar(top_10_countries['Country'], top_10_countries['Population'])

# 添加标题和标签
plt.title('2020年前10个国家人口')
plt.xlabel('国家')
plt.ylabel('人口数量')

# 显示图形
plt.show()
```

##### 4.2 绘制前10个国家的人口占比饼图

```python
# 绘制饼图
plt.pie(top_10_countries['Population_Percentage'], labels=top_10_countries['Country'], autopct='%1.1f%%')

# 添加标题
plt.title('2020年前10个国家人口占比')

# 显示图形
plt.show()
```

##### 4.3 绘制全球人口增长折线图

```python
# 计算每年的全球总人口
global_population = df.groupby('Year')['Population'].sum().reset_index()

# 绘制折线图
plt.plot(global_population['Year'], global_population['Population'])

# 添加标题和标签
plt.title('全球人口增长')
plt.xlabel('年份')
plt.ylabel('人口数量')

# 显示图形
plt.show()
```

---

## 问题解答

1. **如何处理数据中的异常值？**
   可以使用`describe()`函数查看数据的统计信息，找出异常值，并使用条件筛选或替换的方法进行处理，例如：
   ```python
   df = df[df['Population'] < 1e9]
   ```

2. **如何将多个图表绘制在一个图中？**
   可以使用`subplot()`函数在一个图中绘制多个子图，例如：
   ```python
   plt.subplot(2, 1, 1)
   plt.plot(x, y1)
   plt.subplot(2, 1, 2)
   plt.plot(x, y2)
   ```

3. **如何在图表中添加图例？**
   可以使用`legend()`函数在图表中添加图例，例如：
   ```python
   plt.plot(x, y1, label='线1')
   plt.plot(x, y2, label='线2')
   plt.legend()
   ```

---

## 小结

在这一小时的课程中，我们通过一个综合性的项目练习，结合数据处理和可视化技术，对一个完整的数据集进行了处理和分析，并生成了各种图表。通过这个项目，我们巩固了之前学到的数据处理和绘图技术，并学会了如何在实际应用中进行数据分析和可视化。接下来我们将继续学习更多的编程知识，敬请期待！

---
