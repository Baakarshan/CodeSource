
# LCR 075. 数组的相对排序

## 题目描述

给定两个数组，`arr1` 和 `arr2`，

- `arr2` 中的元素各不相同
- `arr2` 中的每个元素都出现在 `arr1` 中

对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

## 示例

输入：`arr1 = [2,3,1,3,2,4,6,7,9,2,19]`, `arr2 = [2,1,4,3,9,6]`  
输出：`[2,2,2,1,4,3,3,9,6,7,19]`

## 提示

- `1 <= arr1.length, arr2.length <= 1000`
- `0 <= arr1[i], arr2[i] <= 1000`
- `arr2` 中的元素 `arr2[i]` 各不相同
- `arr2` 中的每个元素 `arr2[i]` 都出现在 `arr1` 中

注意：本题与主站 1122 题相同：[https://leetcode-cn.com/problems/relative-sort-array/](https://leetcode-cn.com/problems/relative-sort-array/)

## 我的原始代码

```python
from typing import List


class Solution:
    def get_times(self, number, arr1: List[int]) -> int:
        # 初始化计数器
        times = 0
        # 遍历数组 arr1，统计 number 出现的次数
        for i in arr1:
            if i == number:
                times = times + 1
        # 返回 number 出现的次数
        return times

    def get_remaining_times(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 初始化一个空数组，用于存放 arr1 中不在 arr2 中的元素
        arr3: List[int] = []
        # 遍历数组 arr1
        for i in arr1:
            # 如果元素 i 不在数组 arr2 中，则将其添加到 arr3
            if i not in arr2:
                arr3.append(i)
        # 返回 arr3
        return arr3

    def selection_sort(self, arr) -> List[int]:
        # 初始化一个空数组，用于存放排序后的元素
        sorted_arr = []
        # 当原数组 arr 还有元素时，继续排序
        while arr:
            # 初始化最小值索引为 0
            min_index = 0
            # 遍历数组 arr，找到最小值的索引
            for i in range(1, len(arr)):
                if arr[i] < arr[min_index]:
                    min_index = i
            # 将最小值添加到排序后的数组 sorted_arr 中
            sorted_arr.append(arr.pop(min_index))
        # 返回排序后的数组
        return sorted_arr

    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 初始化一个空数组 arr
        arr: List[int] = []
        # 遍历数组 arr2，根据 arr2 的顺序和出现次数将元素添加到 arr 中
        for i in range(len(arr2)):
            times = self.get_times(arr2[i], arr1)
            arr.extend([arr2[i]] * times)
        # 将剩余的元素排序后添加到 arr 中
        arr = arr + self.selection_sort(self.get_remaining_times(arr1, arr2))
        # 返回相对排序后的数组
        return arr

```

## 系统评价

- 执行用时分布
  - 55ms, 击败 5.05%
- 消耗内存分布
  - 16.56MB, 击败 37.88%

## 改进一次的代码

```python
from typing import List
from collections import Counter


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 统计arr1中每个元素出现的次数
        count = Counter(arr1)
        
        # 按照arr2中的顺序添加元素
        result = []
        for num in arr2:
            result.extend([num] * count.pop(num, 0))
        
        # 对剩余的元素进行排序
        remaining_elements = sorted(count.elements())
        result.extend(remaining_elements)
        
        return result

```

以下是改进的具体点：

1. **使用 `Counter` 统计元素频率**：
    - 原始代码通过遍历数组来统计每个元素的出现次数，需要额外定义一个方法。
    - 改进后的代码使用 `Counter` 类直接统计数组中每个元素的频率，简化了统计过程，提高了效率。

2. **简化剩余元素处理**：
    - 原始代码需要一个方法来获取数组中不在另一个数组中的元素，并对这些元素进行排序。
    - 改进后的代码使用 `Counter.elements()` 方法直接获取剩余元素，并对其进行排序，减少了代码的复杂度。

3. **代码简洁**：
    - 原始代码分为多个辅助方法来实现功能，逻辑较为分散。
    - 改进后的代码将所有逻辑集中在一个方法中，直接处理元素频率统计、顺序添加和剩余元素排序，使代码更为简洁明了。

## 系统评价

- 执行用时分布
  - 57ms, 击败 5.05%
- 消耗内存分布
  - 16.60MB, 击败 15.15%
  
## 改进两次的代码

```python
from typing import List


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 创建字典来记录 arr2 中元素的顺序
        order_dict = {value: index for index, value in enumerate(arr2)}

        # 将 arr1 中的元素分成两部分
        in_arr2 = [x for x in arr1 if x in order_dict]
        not_in_arr2 = [x for x in arr1 if x not in order_dict]

        # 对两部分分别进行排序
        in_arr2.sort(key=lambda x: order_dict[x])
        not_in_arr2.sort()

        # 合并两部分得到最终结果
        return in_arr2 + not_in_arr2

```

以下是最新改进的具体点：

1. **使用字典记录顺序**：
    - 原始代码通过遍历 `arr2` 来添加元素。
    - 改进后的代码创建了一个字典 `order_dict`，记录 `arr2` 中每个元素的顺序，简化了排序过程。

2. **分离并排序元素**：
    - 原始代码使用 `Counter` 和 `elements()` 方法来统计和排序元素。
    - 改进后的代码将 `arr1` 中的元素分成两部分：在 `arr2` 中的元素和不在 `arr2` 中的元素，并分别进行排序。

3. **合并结果**：
    - 原始代码将剩余元素排序后添加到结果中。
    - 改进后的代码将两部分元素合并，直接得到最终结果，更加直观简洁。

这次改进后的代码逻辑更加清晰，性能也有所提升，因为通过字典查找和列表推导式，减少了不必要的遍历和计算。

## 系统评价

- 执行用时分布
  - 44ms, 击败 27.27%
- 消耗内存分布
  - 16.59MB, 击败 21.21%  
  
## 改进三次的代码

```python
from typing import List


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 创建一个字典k，存储arr2中的元素及其对应的索引
        k = {b: i for i, b in enumerate(arr2)}

        # 使用sorted函数对arr1进行排序
        # key函数会根据元素在字典k中的索引进行排序，如果元素不在arr2中，则按1000+元素值排序
        return sorted(arr1, key=lambda val: k.get(val, 1000 + val))

```

### 实现方式介绍

1. **创建字典 k**：
    - 使用字典推导式创建一个字典 `k`，存储 `arr2` 中的元素及其对应的索引。
    - `enumerate(arr2)` 生成一系列的 `(index, value)` 对，其中 `index` 是元素在 `arr2` 中的索引，`value` 是元素本身。
    - 通过 `{b: i for i, b in enumerate(arr2)}` 创建的字典 `k`，其键是 `arr2` 中的元素，值是其对应的索引。

2. **使用 sorted 函数进行排序**：
    - `sorted(arr1, key=lambda val: k.get(val, 1000 + val))` 使用 `sorted` 函数对 `arr1` 进行排序，并指定了一个排序键函数。
    - 排序键函数 `lambda val: k.get(val, 1000 + val)` 确定每个元素的排序优先级：
        - 如果元素 `val` 在字典 `k` 中，则返回其在 `k` 中对应的索引，即 `k[val]`。
        - 如果元素 `val` 不在字典 `k` 中，则返回 `1000 + val`，确保这些元素在排序结果中位于最后，并按其自然顺序排序。

## 以下是最新改进的具体点：

1. **简化排序逻辑**：
    - 原始代码通过将 `arr1` 中的元素分成两部分，并分别排序，然后合并得到结果。
    - 改进后的代码通过使用 `sorted` 函数和一个自定义的排序键函数，直接对 `arr1` 进行排序，简化了排序逻辑。

2. **使用字典进行索引查找**：
    - 原始代码通过创建一个 `order_dict` 来记录 `arr2` 中元素的顺序，并在排序时使用。
    - 改进后的代码同样创建了一个字典 `k`，存储 `arr2` 中的元素及其对应的索引，但在排序键函数中更高效地使用了该字典。

3. **统一排序逻辑**：
    - 原始代码将不在 `arr2` 中的元素排序时使用了不同的方法。
    - 改进后的代码通过自定义排序键函数，将不在 `arr2` 中的元素统一按 `1000 + 元素值` 进行排序，使得整个排序过程更为一致和简洁。

这次改进后的代码更加简洁和高效，通过使用 `sorted` 函数和自定义的排序键函数，实现了对 `arr1` 的相对排序。

## 系统评价
- 执行用时分布
  - 39ms, 击败 57.58%
- 消耗内存分布
  - 16.54MB, 击败 47.47%  

## 优秀代码

```python
from typing import List


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        r = {}  # 创建一个字典，用于存储arr2中元素的顺序和arr1中未出现的元素的排序权重

        # 遍历arr2，将其元素的顺序存储在字典r中
        for n in arr2:
            r[n] = len(r)  # 每个元素的值为其在arr2中的索引

        s = len(r)  # 记录arr2中元素的数量，用于处理arr1中未在arr2中出现的元素

        # 遍历arr1中的元素，如果元素不在r中，则赋予一个较大的排序权重
        for n in arr1:
            if n not in r:
                r[n] = s + n  # 未在arr2中出现的元素，其权重为s（即arr2中元素的数量）加上该元素的值

        # 使用字典r中的值作为键，对arr1进行排序
        arr1.sort(key=lambda x: r[x])

        return arr1  # 返回排序后的arr1

```

## 系统评价

- 执行用时分布
  - 29ms, 击败 97.98%
- 消耗内存分布
  - 16.46MB, 击败 79.80%
  
## 优秀代码

```python
from typing import List


class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 创建一个哈希表来存储arr1中元素的出现次数
        hash_table = [0] * 1001  # 假设数组中的元素都在0到1000之间
        for num in arr1:
            hash_table[num] += 1  # 记录每个元素的出现次数

        # 按照arr2的顺序将元素填充到arr1中
        index = 0  # 初始化索引
        for num in arr2:
            while hash_table[num] > 0:  # 当num在arr1中出现时
                arr1[index] = num  # 按顺序将num放入arr1
                index += 1  # 更新索引
                hash_table[num] -= 1  # 减少该元素的计数

        # 将剩余元素按升序填充到arr1中
        for num in range(len(hash_table)):
            while hash_table[num] > 0:  # 当num在arr1中仍有剩余时
                arr1[index] = num  # 按顺序将num放入arr1
                index += 1  # 更新索引
                hash_table[num] -= 1  # 减少该元素的计数

        return arr1  # 返回排序后的arr1

```

## 系统评价

- 执行用时分布
  - 29ms, 击败 97.98%
- 消耗内存分布
  - 16.52MB, 击败 54.04%